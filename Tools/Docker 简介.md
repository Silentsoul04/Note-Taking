**Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口，一种可在同样硬件上实现不同环境的软件。**它是目前最流行的 Linux 容器解决方案。

要解释清楚Docker，首先要说解释清楚容器（Container）的概念。要解释容器的话，需要从操作系统说起。

***

## 操作系统

**操作系统**（Operating System，缩写：OS）是管理计算机硬件与软件资源的系统软件。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作界面。 

简而言之，操作系统是管理计算机的硬件软件和资源，并且为软件运行提供通用服务的系统软件：

* 硬件管理：包括分配CPU时间、内存；从网络、存储设备等IO设备读写数据。
* 软件管理：就是各种软件的运行，线程、进程调度之类的工作。
* 为软件提供运行环境：运行环境通常一部分由操作系统内核（Kernel）提供，另一部分由运行库（Runtime Library）提供。

硬件、操作系统、应用程序之间的关系可以简单的用下图表示：

```text
+--------------------------+
|       Applications       |
+--------------------------+
|+------------------------+|
||    Runtime Library     ||
|+------------------------+|
||         Kernel         ||
|+------------------------+|
|     Operating System     |
+-----+--------+-----------+
| CPU | Memory | IO Device |
+-----+--------+-----------+ 
```

随着硬件的性能提升，以及软件种类的丰富，有两种情况变得很常见：

1. 硬件性能过剩——很多计算机的硬件配置，即使不能完全满足峰值性能的要求，也往往会有大量时间处于硬件资源闲置的状态。例如一般家用电脑，已经是四核、六核的配置了，除了3A游戏、视频制作、3D渲染、高性能计算等特殊应用外，通常有90%以上时间CPU是闲置的。
2. 软件冲突——因为业务需要，两个或者多个软件之间冲突，或者需要同一个软件的不同版本。例如早几年做web前端的，要测试网页在不同版本的IE上是否能正常显示，然而Windows只能装一个版本的IE。

为了解决软件冲突，只能配置多台计算机，或者很麻烦的在同一台电脑上安装多个操作系统，通过重启来进行切换。显然这两个方案都有其缺点：多台计算机成本太高，多操作系统的安装、切换都很麻烦。在硬件性能过剩的时候，硬件虚拟化的普及就很自然而然的提出来了。

为了解决软件冲突，只能配置多台计算机，或者很麻烦的在同一台电脑上安装多个操作系统，通过重启来进行切换。显然这两个方案都有其缺点：多台计算机成本太高，多操作系统的安装、切换都很麻烦。在硬件性能过剩的时候，硬件虚拟化的普及就很自然而然的提出来了。

***

## 硬件虚拟化

**硬件虚拟化**（Hardware virtualization）是一种对计算机或操作系统的虚拟。虚拟化对用户隐藏了真实的计算机硬件，表现出另一个抽象计算平台。 平台虚拟化表现为在一个给定硬件平台的宿主机上创造一个模拟的计算机环境（虚拟机）提供给客户机。

硬件虚拟化通过某个特殊的软件，仿真出一台或者多台计算机的各种硬件，用户可以在这一台虚拟机上安装、运行操作系统（一般叫来宾操作系统，Guest OS）和各种应用，并且把Guest OS和上面应用软件对硬件资源的访问转发到底层的硬件上来实现。对于Guest OS和上面的应用程序来说，这台虚拟机和普通的物理计算机是完全一样没有任何区别的——除了性能可能差一点。著名的VMware就是这么一个软件，这类软件英语有一个专用的单词是Hypervisor。
Hypervisor，又称**虚拟机监视器**（virtual machine monitor，缩写为 VMM），是用来创建与运行虚拟机的软件、固件或硬件。 被 hypervisor 用来运行一个或多个虚拟机的计算机称为宿主机（host machine），这些虚拟机则称为客户机（guest machine）。Hypervisor 提供虚拟的作业平台来运行客操作系统（guest operating systems），负责管理其他客操作系统的运行阶段；这些客操作系统，共同分享虚拟化后的硬件资源。 

Hypervisor根据其对硬件资源的访问方式，可以分为两大类：

* Type I：原生或裸机 hypervisor。这些虚拟机管理程序直接运行在宿主机的硬件上来控制硬件和管理客操作系统。直接访问硬件资源，例如VMware EXSi，Windows的Hyper-V，Linux的Xen；特点：
  * 需要硬件支持
  * 虚拟机监视器作为主操作系统
  * 运行效率高
* Type II：寄居或托管 hypervisor。这些虚拟机管理程序运行在传统的操作系统上，就像其他计算机程序那样运行。Hypervisor和普通的应用一样，运行在某个操作系统（例如Windows或者Linux等，这里称之为宿主机操作系统，Host OS）之上，Hypervisor通过Host OS访问硬件资源，例如VMware Workstation，Virtual Box等。特点：
  * 虚拟机监视器作为应用程序运行在主操作系统环境内
  * 运行效率一般较类型 I 低

两种类型的Hypervisor区别如图所示：

```text
                             +-----+-----+-----+-----+
                             |App A|App B|App C|App D|
+-----+-----+-----+-----+    +-----+-----+-----+-----+
|App A|App B|App C|App D|    |Guest|Guest|Guest|Guest|
+-----+-----+-----+-----+    | OS0 | OS1 | OS2 | OS3 |
|Guest|Guest|Guest|Guest|    +-----+-----+-----+-----+
| OS0 | OS1 | OS2 | OS3 |    |        Hypervisor     |
+-----+-----+-----+-----+    +-----------------------+
|        Hypervisor     |    |         Host OS       |
+-----------------------+    +-----------------------+
|        Hardware       |    |        Hardware       |
+-----------------------+    +-----------------------+
          Type I                       Type II
```

虚拟机的一个缺点在于 Guest OS 通常会占用不少硬件资源。即使是没有图形界面的Linux，根据发行版以及安装软件的不同也会占用100~1G内存，1~4G硬盘空间。而且为了应用系统运行的性能，往往还要给每台虚拟机留出更多的内存容量。虽然不少 Hypervisor 支持动态内存，但基本上都会降低虚拟机的性能。如果说这样的资源占用少量的虚拟机还可以接受的话，同时运行十数台数十台虚拟机的时候，浪费的硬件资源就相当可观了。通常来说，其中相当大部分甚至全部 Guest OS 都是相同的。

能不能所有的应用使用**同一个的操作系统**具有以下功能？

* 减少硬件资源的浪费
* 又能避免包括运行库运行库在内的软件冲突

操作系统层虚拟化（容器）概念的提出，就是为了解决这个问题。

***

## 操作系统层虚拟化(容器化)

**操作系统层虚拟化**（OS-level virtualization），**亦称容器化**（Containerization），是一种虚拟化技术，这种技术将操作系统内核虚拟化，可以允许用户空间软件实例（instances）被分割成几个独立的单元，在内核中运行，而不是只有一个单一实例运行。 

在操作系统层虚拟化中，独立主机被虚拟化在操作系统层中，这使得多个独立且安全虚拟化的服务器运行在一台计算机上。客户操作系统环境与宿主服务器分享同一个操作系统。程序运行在被视为独立系统的客户机环境中。

**LXC**，其名称来自Linux软件容器（Linux Containers）的缩写，一种操作系统层虚拟化（Operating system–level virtualization）技术，为Linux内核容器功能的一个用户空间接口。它将应用软件系统打包成一个软件容器（Container），内含应用软件本身的代码，以及所需要的操作系统核心和库。透过统一的名字空间和共享API来分配不同软件容器的可用硬件资源，创造出应用程序的独立沙箱运行环境，使得Linux用户可以容易的创建和管理系统或应用容器。

Docker 依赖的 Linux 内核特性：

* **Namespaces 命名空间**
* **Control groups (cgroups)  控制组**

***

### 命名空间

**命名空间**它表示着一个标识符（identifier）的可见范围。同一个标识符可在多个名字空间中定义，但它在不同名字空间中的含义是互不相干的。这样，在一个新的名字空间中可定义任何标识符，它们不会与任何已有的标识符发生冲突，因为已有的定义都处于其他名字空间中。 这一特点是使用命名空间的主要理由。在大型的计算机程序或文档中，往往会出现数百或数千个标识符。名字空间提供一隐藏区域标识符的机制。通过将逻辑上相关的标识符组织成相应的名字空间，可使整个系统更加模块化。 

在编程语言中，命名空间意味着：封装 --> 代码隔离。

* 命名空间是对作用域的一种特殊的抽象，它包含了处于该作用域内的标识符，且本身也用一个标识符来表示，这样便将一系列在逻辑上相关的标识符用一个标识符组织了起来。在一些编程语言（例如C++和Python）中，名字空间本身的标识符也属于一个外层的名字空间，也即名字空间可以嵌套，构成一个名字空间树，树根则是无名的全局名字空间。
* 函数和类的作用域可被视作隐式名字空间，它们和可见性、可访问性和对象生命周期不可分割的联系在一起。 

在操作系统中，命名空间意味着：

* 系统资源的隔离
* 进程、网络、文件系统...

***

### cgroups

**cgroups**，其名称源自控制组群（control groups）的简写，是Linux内核的一个功能，用来限制、控制与分离一个进程组的资源（如CPU、内存、磁盘输入输出等）。 

cgroups的一个设计目标是为不同的应用情况提供统一的接口，从控制单一进程（像nice）到操作系统层虚拟化（像OpenVZ，Linux-VServer，LXC）。cgroups提供：

- 资源限制：组可以被设置不超过设定的内存限制；这也包括虚拟内存。
- 优先级限定：一些组可能会得到大量的CPU 或磁盘IO吞吐量。
- 资源计量：用来衡量系统确实把多少资源用到适合的目的上。
- 资源控制：冻结组或检查点和重启动。

LXC利用cgroups与名称空间的功能，提供应用软件一个独立的操作系统环境。LXC不需要Hypervisor这个软件层，软件容器（Container）本身极为轻量化，提升了创建虚拟机的速度。软件Docker被用来管理LXC的环境。 

在Linux内核中，提供了cgroups功能，来达成资源的区隔化。它同时也提供了命名空间区隔化的功能，使应用程序看到的操作系统环境被区隔成独立区间，包括行程树，网络，用户id，以及挂载的文件系统。但是cgroups并不一定需要引导任何虚拟机。

***

### Docker 容器的能力

* 文件系统的隔离：每个容器都有自己的 root 文件系统；
* 进程隔离：每个容器都运行在自己的进程环境中；
* 网络隔离：容器间的虚拟网络接口和IP地址彼此分离
* 资源隔离与分组：使用 cgroups 将 CPU、内存等资源独立分配给每个docker容器。

***

## Docker

操作系统层虚拟化之后，可以实现软件的**即时迁移**（Live migration），即使一个容器移动到另一个操作系统下，也可以重新运行起来。但是在这种技术下，只能在**同样的操作系统**下进行。 

相对于传统的**虚拟化**（Virtualization），**容器化**的优势在于占用服务器空间少，通常几秒内即可引导。同时容器的弹性可以在资源需求增加时瞬时复制增容，在资源需求减小时释放空间以供其他用户使用。由于在同一台服务器上的容器实例共享同一个系统内核，因此在运行上不会存在实例与主机操作系统争夺RAM的问题发生，从而能够保证实例的性能。

容器和Type II虚拟机、物理机的区别见下图：

```text
+-----+-----+-----+-----+                                   +-----+-----+-----+-----+
|App A|App B|App C|App D|     +-----+-----+-----+-----+     |App A|App B|App C|App D|
+-----+-----+-----+-----+     |App A|App B|App C|App D|     +-----+-----+-----+-----+
|+---------------------+|     +-----+-----+-----+-----+     |Guest|Guest|Guest|Guest|
||   Runtime Library   ||     |Lib A|Lib B|Lib C|Lib D|     | OS0 | OS1 | OS2 | OS3 |
|+---------------------+|     +-----+-----+-----+-----+     +-----+-----+-----+-----+
||       Kernel        ||     |    Container Engine   |     |        Hypervisor     |
|+---------------------+|     +-----------------------+     +-----------------------+
|   Operating System    |     |         Host OS       |     |         Host OS       |
+-----------------------+     +-----------------------+     +-----------------------+
|       Hardware        |     |        Hardware       |     |        Hardware       |
+-----------------------+     +-----------------------+     +-----------------------+
    Physical Machine                  Container                 Type II Hypervisor
```

上图中，每一个App和Lib的组合，就是一个容器。也就是Docker图标里面的一个集装箱。和虚拟机相比，容器有以下优点：

* 迅速启动：没有虚拟机硬件的初始化，没有Guest OS的启动过程，可以节约很多启动时间，这就是容器的“开箱即用”。
* 占用资源少：没有运行Guest OS所需的内存开销，无需为虚拟机预留运行内存，无需安装、运行App不需要的运行库/操作系统服务，内存占用、存储空间占用都小的多。相同配置的服务器，如果运行虚拟机只能运行十多台的，通常可以运行上百个容器毫无压力——当然前提是单个容器应用本身不会消耗太多资源。

当然，和虚拟机相比，因为共用内核，只靠cgroup隔离，应用之间的隔离是不如虚拟机彻底的，如果某个应用运行时导致内核崩溃，所有的容器都会崩溃。而虚拟机内的应用崩溃，理论上是不会影响其它虚拟机以及上面运行的应用的，除非是硬件或者Hypervisor有Bug。

Docker把App和Lib的文件打包成为一个镜像，并且采用类似多次快照的存储技术，例如aufs/device mapper/btrfs/zfs等，可以实现：

* 多个App可以共用相同的底层镜像（初始的操作系统镜像）
* App运行时的IO操作和镜像文件隔离；
* 通过挂载包含不同配置/数据文件的目录或者卷（Volume），单个App镜像可以同时用来运行无数个不同业务的容器。

```text
+---------+  +---------+  +---------+    +-----+ +-----+ +-----+
| abc.com |  | def.com |  | xyz.com |    | DB1 | | DB2 | | DB3 |    
+----+----+  +----+----+  +----+----+    +--+--+ +--+--+ +--+--+    
     |            |            |            |       |       |
+----+----+  +----+----+  +----+----+    +--+--+ +--+--+ +--+--+    
| abc.com |  | def.com |  | xyz.com |    | DB1 | | DB2 | | DB3 |
| config  |  | config  |  | config  |    | conf| | conf| | conf|
|  data   |  |  data   |  |  data   |    | data| | data| | data|
+----+----+  +----+----+  +----+----+    +--+--+ +--+--+ +--+--+
     |            |            |            |       |       |
     +------------+------------+            +-------+-------+
                  |                                 |
           +------+------+                   +------+------+          
           | Nginx Image |                   | MySQL Image |
           +------+------+                   +------+------+
                  |                                 |
                  +----------------+----------------+
                                   |
                            +------+-------+ 
                            | Alpine Image |
                            +------+-------+
```

上图是基于一个Alpine Linux的镜像，分别建立了Nginx和MySQL的镜像，并且挂载不同的配置/数据同时运行3个网站应用3个数据库应用的示意图。

此外，Docker公司提供公共的**镜像仓库**（Docker称之为Repository），Github connect，自动构建镜像，大大简化了应用分发、部署、升级流程。加上Docker可以非常方便的建立各种自定义的镜像文件，这些都是Docker成为最流行的容器技术的重要因素。

通过以上这些技术的组合，最后的结果就是，绝大部分应用，开发者都可以通过docker build创建镜像，通过docker push上传镜像，用户通过docker pull下载镜像，用docker run运行应用。用户不需要再去关心如何搭建环境，如何安装，如何解决不同发行版的库冲突——而且通常不会需要消耗更多的硬件资源，不会明显降低性能。这就是其他答主所说的标准化、集装箱的原因所在。

综上所述：

Docker利用Linux核心中的资源分离机制，例如cgroups，以及Linux核心名字空间（namespaces），来创建独立的容器（containers）。Linux核心对名字空间的支持完全隔离了工作环境中应用程序的视野，包括行程树、网络、用户ID与挂载文件系统，而核心的cgroup提供资源隔离，包括CPU、存储器、block I/O与网络。**LXC不是模拟一个完整的操作系统，而是对进程进行隔离**，提供一个额外的软件**抽象层**，使用操作系统层虚拟化，在称为**容器**的包中运行软件。 仍然只有一个内核、一个调度程序和一个内核内存管理器。由于容器是进程级别的，相比虚拟机有很多优势。

Docker使用 host OS 内核，容器内没有自定义或附加内核。在机器上运行的所有容器都共享这个“host”内核。每个container中运行的进程，是的的确确运行在host上的（用ps 可以查看的到)，这样的话，无论你的镜像是基于ubuntu，centos，还是debian的，都是运行在主机内核上的（container中没有自己的内核）。也就是说如果主机内核不满足需求，container中的依赖此特性的应用程序就无法运行

Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。

***

参考：

[如何通俗解释Docker是什么？](https://www.zhihu.com/question/28300645/answer/585166942)，木头龙

[docker的几点疑问](https://www.zhihu.com/question/25394149/answer/30671258)，Honglin Feng