## 插入排序

插入排序（Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到 $O(1)$的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。

### 算法

一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下： 

1. 从第一个元素开始，该元素可以认为**已经被排序**
2. 取出下一个元素，在**已经排序的元素序列中从后向前扫描**
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
5. 将**新元素插入到该位置后**
6. 重复步骤2~5

### 复杂度

时间复杂度：
$$
O(n^2)
$$

### 示例

```python
def insertion_sort(iterable):
    lst = list(iterable)
    lst_len = len(lst)
    if lst_len==1: return lst
    for i in range(1, lst_len):
        for j in range(i, 0, -1):	# 从后向前扫描，从而，首先元素与已排序中最大的元素
            if lst[j] < lst[j-1]:
                lst[j], lst[j-1] = lst[j-1], lst[j]
            else:
                break
    return lst
```

### 插入排序VS冒泡排序

冒泡排序是与插入排序拥有相等的运行时间，但是两种算法在需要的**交换次数却很大地不同**。在最坏的情况，冒泡排序需要 $O(n^2)$次交换，而插入排序只要最多$O(n)$交换。冒泡排序的实现（类似下面）通常会对已经排序好的数列拙劣地运行（$O(n^2)$），而插入排序在这个例子只需要$O(n)$个运算。因此很多现代的算法教科书避免使用冒泡排序，而用插入排序取代之。冒泡排序如果能在内部循环第一次运行时，使用一个旗标来表示有无需要交换的可能，也可以把最优情况下的复杂度降低到$O(n)$。在这个情况，已经排序好的数列就无交换的需要。若在每次走访数列时，把走访顺序反过来，也可以稍微地改进效率。有时候称为鸡尾酒排序，因为算法会从数列的一端到另一端之间穿梭往返。 

------

## 二分法插入排序

二分法插入排序（Binary Insert Sort），简称二分排序。在插入排序的基础上，如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的数目。该算法可以认为是插入排序的一个变种。

### 算法

1. 二分查找，确认位置
2. 插入新元素

### 复杂度

时间复杂度：
$$
O(n^\sqrt2)
$$

### 示例

```python
import bisect

def insertion_sort(iterable):
    lst = list(iterable)
    lst_len = len(lst)
    lst_new = []
    if lst_len==1: return lst
    for i in range(lst_len):
        bisect.insort_right(lst_new, i)
    return lst_new
```

------

## 希尔排序

希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。

希尔排序是基于插入排序的以下两点性质而提出改进方法的：

* 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率
* 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位

### 算法

希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。 

例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样： 

```text
13 14 94 33 82
25 59 94 65 23
45 27 73 25 39
10
```

然后我们对每列进行排序： 

```text
10 14 73 25 23
13 27 94 33 39
25 59 94 65 82
45
```

将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ].这时10已经移至正确位置了，然后再以3为步长进行排序： 

```text
10 14 73
25 23 13
27 94 33
39 25 59
94 65 82
45
```

排序之后变为： 

```text
10 14 13
25 23 33
27 25 59
39 65 73
45 94 82
94
```

最后以1步长进行排序（此时就是简单的插入排序了）。 

步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为普通插入排序，这就保证了数据一定会被排序。

已知的最好步长序列是由Sedgewick提出的(1, 5, 19, 41, 109,...)，该序列的项来自 $9 \times 4^i -9 \times 2^i + 1$ 和 $ 2^{i+2} + (2^{i+2} - 3) + 1$ 这两个算式。这项研究也表明“比较在希尔排序中是最主要的操作，而不是交换。”用这样步长序列的希尔排序比插入排序要快，甚至在小数组中比快速排序和堆排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。

另一个在大数组中表现优异的步长序列是（斐波那契数列除去0和1将剩余的数以黄金分割比的两倍的幂进行运算得到的数列）：(1, 9, 34, 182, 836, 4025, 19001, 90358, 428481, 2034035, 9651787, 45806244, 217378076, 1031612713,…)

### 复杂度

时间复杂度：

在希尔排序中，元素的比较次数和步长gap的选择之间的数学公式很难计算。根据经验，希尔排序的时间复杂度在$O(n logn)$到$O(n^2)$之间，平均时间复杂度是$O(n^{1.3})$。  

### 示例

伪代码：

```text
input: an array a of length n with array elements numbered 0 to n − 1
inc ← round(n/2)
while inc > 0 do:    
    for i = inc .. n − 1 do:        
        temp ← a[i]        
        j ← i        
        while j ≥ inc and a[j − inc] > temp do:            
            a[j] ← a[j − inc]            
            j ← j − inc        
        a[j] ← temp    
    inc ← round(inc / 2)
```

代码：

```python
def shell_sort(list):
    n = len(list)
    gap = n // 2    # 初始步长
    while gap > 0:
        for i in range(gap, n): # 每个步长进行插入排序           
            temp = list[i]
            j = i           
            while j >= gap and list[j - gap] > temp:    # 插入排序
                list[j] = list[j - gap]
                j -= gap
            list[j] = temp       
        gap = gap // 2  # 得到新的步长
    return list
```

***





***

参考：

wiki

http://blog.timd.cn/sort/shell-sort/