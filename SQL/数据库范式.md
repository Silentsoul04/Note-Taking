## 第一范式（1NF）

**符合1NF的关系中的每个属性都不可再分。**数据库表的每一列(即每个属性)都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。简而言之，第一范式就是无重复的列。

关系模式”和“关系”的区别，类似于面向对象程序设计中”类“与”对象“的区别。”关系“是”关系模式“的一个实例，你可以把”关系”理解为一张带数据的表，而“关系模式”是这张数据表的表结构。

下图就不符合1NF的要求。

![](https://note-taking-1258869021.cos.ap-beijing.myqcloud.com/SQL/1NF%201.jpg)

**1NF是所有关系型数据库的最基本要求**，不满足第一范式（1NF）的数据库就不是关系数据库。在关系型数据库管理系统（RDBMS），例如SQL Server，Oracle，MySQL中创建数据表的时候，如果数据表的设计不符合这个最基本的要求，那么操作一定是不能成功的。也就是说，只要在RDBMS中已经存在的数据表，一定是符合1NF的。如果我们要在RDBMS中表现表中的数据，就得设计为下表的形式：
![](https://note-taking-1258869021.cos.ap-beijing.myqcloud.com/SQL/1NF%202.jpg)

***

## 第二范式（2NF）

但是仅仅符合1NF的设计，仍然会存在数据冗余过大，插入异常，删除异常，修改异常的问题，例如对于下表中的设计：

![](https://note-taking-1258869021.cos.ap-beijing.myqcloud.com/SQL/2NF%201.jpg)

1. **数据冗余过大**。每一名学生的学号、姓名、系名、系主任这些数据重复多次。每个系与对应的系主任的数据也重复多次；
2. **插入异常**。假如学校新建了一个系，但是暂时还没有招收任何学生（由于没人选修，没有学号关键字，只能等有人选修才能把系名与系主任存入，那么是无法将这些属性单独地添加到数据表中去）；
   * 根据三种关系完整性约束中实体完整性的要求，关系中的码所包含的任意一个属性都不能为空，所有属性的组合也不能重复。为了满足此要求，图中的表，只能将学号与课名的组合作为码，否则就无法唯一地区分每一条记录。
   * 码：关系中的某个属性或者某几个属性的组合，用于区分每个元组（可以把“元组”理解为一张表中的每条记录，也就是每一行）。
3. **删除异常**。假如将某个系中所有学生相关的记录都删除，那么所有系与系主任的数据也就随之消失了（一个系所有学生都没有了，并不表示这个系就没有了）。
4. **修改异常**。假如李小明转系到法律系，那么为了保证数据库中数据的一致性，需要修改三条记录中系与系主任的数据。

**2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖。**这句话中涉及到的四个概念：

* 函数依赖
* 码
* 非主属性
* 部分函数依赖

### 函数依赖

若在一张表中，在属性（或属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说Y函数依赖于X，写作 X → Y。也就是说，在数据表中，不存在任意两条记录，它们在X属性（或属性组）上的值相同，而在Y属性上的值不同。这也就是“函数依赖”名字的由来，类似于函数关系 y = f(x)，在x的值确定的情况下，y的值一定是确定的。

例如，对于上表中的数据，找不到任何一条记录，它们的学号相同而对应的姓名不同。所以我们可以说姓名函数依赖于学号，写作 学号 → 姓名。但是反过来，因为可能出现同名的学生，所以有可能不同的两条学生记录，它们在姓名上的值相同，但对应的学号不同，所以我们不能说学号函数依赖于姓名。表中其他的函数依赖关系还有如：

* 系名 → 系主任
* 学号 → 系主任
* 学号，课名） → 分数

但以下函数依赖关系则不成立：

* 学号 → 课名
* 学号 → 分数
* 课名 → 系主任
* （学号，课名） → 姓名

从“函数依赖”这个概念展开，还会有三个概念：

#### 完全函数依赖

设 X,Y 是关系 R 的两个属性集合，存在 X→Y，若 X’ 是 X 的真子集，但对每一个 X’ 都有 X’!→Y，则称 Y 完全函数依赖于 X。

![](https://note-taking-1258869021.cos.ap-beijing.myqcloud.com/SQL/2NF%202.jpg)

例如：

学生基本信息表R中（学号，姓名，系名，系主任，课名，分数），学号是唯一的，姓名可能会有重复。

* 学号 F→ 姓名 
* （学号，课名） F→ 分数  （注：因为同一个的学号对应的分数不确定，同一个课名对应的分数也不确定）

#### 部分函数依赖

设 X,Y 是关系 R 的两个属性集合，存在 X→Y，若 X’ 是 X 的真子集，存在 X’→Y，则称 Y 部分函数依赖于 X。

![](https://note-taking-1258869021.cos.ap-beijing.myqcloud.com/SQL/2NF%203.jpg)

例如：

* （学号，课名） P→ 姓名 

#### 传递函数依赖

设 X,Y,Z 是关系 R 中互不相同的属性集合，存在 X→Y(Y !→X),Y→Z，则称Z传递函数依赖于X。

![](https://note-taking-1258869021.cos.ap-beijing.myqcloud.com/SQL/2NF%204.jpg)

***

### 码

码是数据系统中的基本概念。所谓码就是能唯一标识实体的属性，他是整个实体集的性质，而不是单个实体的性质。它包括超码，候选码，主码。

* **超码**（Super keyword）也称为超关键字，是一个或多个属性的集合，这些属性的组合可以在一个实体集中唯一的标识一个实体。
  * 如果K是一个超码，那么K的任意超集也是超码。
* 设 K 为某表中的一个属性或属性组，若除 K 之外的所有属性都**完全函数依赖**于 K，那么称 K 为**候选码**，也称为候选关键字。也可以理解为，若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何、子集都不能再标识，则称该属性组为候选码。
  * 超码包括候选码
  * 如果一个超码去掉其中任何一个字段后不再能唯一地确定记录，则称它为候选码。
  * 候选码是最小超码，它们的任意真子集都不能成为超码。
* **主码**(primary key)也称为主关键字，是表中的一个或多个字段，它的值用于唯一地标识表中的某一条记录。
  * 从多个候选码中任意选出一个做为主码，如果候选码只有一个，那么候选码就是主码。
  * 当一个关系有N个属性或属性组可以唯一标识时，则说明该关系有N个候选码，可以选定其中一个作为主码。
  * 一个表只有一个主码

* **主属性**（Prime attribute）在一个关系中，如一个属性是构成某一个候选关键字的属性集中的一个属性
  * 就是包含在任何候选码中的属性
* **非主属性**就是不包含在任何候选码中的属性
  * 非主属性是相对与主属性来定义

例如：

* （学号、课名）这个属性组就是候选码。该表中有且仅有这一个码。（课名和学号均不会重复）
* 主属性就有两个：学号 与 课名。

***

### 2NF

第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式(Second Normal Form,2nd NF)是指每个表必须有且仅有一个数据元素为主码，其他数据元素与主码一一对应。即表中其他数据元素都依赖于主关键字，或称该数据元素惟一地被主关键字所标识。

规则是要求实体的属性完全依赖于主关键字。简而言之，第二范式就是非主属性完全函数依赖于主码。同时可以得出：**如果一个数据表的主键只有单一一个字段的话，它就一定符合第二范式(前提是该数据表符合第一范式。**

根据2NF的定义，判断的依据实际上就是看数据表中**是否存在非主属性对于主码的部分函数依赖**。若存在，则数据表最高只符合1NF的要求，若不存在，则符合2NF的要求。判断的方法是：

* 第一步：找出数据表中所有的**码**。
* 第二步：根据第一步所得到的码，找出所有的**主属性**。
* 第三步：数据表中，除去所有的主属性，剩下的就都是**非主属性**了。
* 第四步：查看是否存在非主属性对码的**部分函数依赖**。

对于上表，根据前面所说的四步，可以这么做：

#### 第一步

1. 查看所有每一单个属性，当它的值确定了，是否剩下的所有属性值都能确定。
2. 查看所有包含有两个属性的属性组，当它的值确定了，是否剩下的所有属性值都能确定。
3. ……
4. 查看所有包含了六个属性，也就是所有属性的属性组，当它的值确定了，是否剩下的所有属性值都能确定。

简而言之，假如A是候选码，那么所有包含了A的属性组，如（A，B）、（A，C）、（A，B，C）等等，都不是候选码了（因为作为候选码的要求里有一个“**完全**函数依赖”）。

下图表示了表中所有的函数依赖关系：

![](https://note-taking-1258869021.cos.ap-beijing.myqcloud.com/SQL/2NF%205.jpg)

这一步完成以后，可以得到，候选码只有一个，就是**（学号、课名）**。

#### 第二步

主属性有两个：**学号** 与 **课名**

#### 第三步

非主属性有四个：**姓名**、**系名**、**系主任**、**分数**

#### 第四步

对于**（学号，课名） → 姓名**，有 **学号 → 姓名**，存在非主属性 **姓名** 对码**（学号，课名）**的部分函数依赖。

对于**（学号，课名） → 系名**，有 **学号 → 系名**，存在非主属性 系**名** 对码**（学号，课名）**的部分函数依赖。

对于**（学号，课名） → 系主任**，有 **学号 → 系主任**，存在非主属性  对码**（学号，课名）**的部分函数依赖。

所以上表存在非主属性对于码的部分函数依赖，最高只符合1NF的要求，不符合2NF的要求。

#### 模式分解

为了让表符合2NF的要求，必须消除这些部分函数依赖，只有一个办法，就是将大数据表拆分成两个或者更多个更小的数据表，在拆分的过程中，要达到更高一级范式的要求，这个过程叫做”模式分解“。模式分解的方法不是唯一的，以下是其中一种方法：

* 选课表（学号，课名，分数）
* 学生表（学号，姓名，系名，系主任）

先来判断以下，选课表与学生表，是否符合了2NF的要求？

* 对于**选课表**，其主码是**（学号，课名）**，主属性是**学号**和**课名**，非主属性是**分数**
  * 学号确定，并不能唯一确定分数，
  * 课名确定，也不能唯一确定分数，
  * 所以不存在非主属性分数对于码 （学号，课名）的部分函数依赖，所以此表符合2NF的要求。

* 对于**学生表**，其码是**学号**，主属性是**学号**，非主属性是**姓名、系名**和**系主任**
  * 因为码只有一个属性，所以不可能存在非主属性对于码 的部分函数依赖，所以此表符合2NF的要求。

下图表示了模式分解以后的新的函数依赖关系：

![](https://note-taking-1258869021.cos.ap-beijing.myqcloud.com/SQL/2NF%206.jpg)

模式分解以后新的数据：

![](https://note-taking-1258869021.cos.ap-beijing.myqcloud.com/SQL/2NF%207.jpg)

综上：

进行同样的操作，是否还存在着之前的那些问题？

1. 修改数据
   李小明转系到法律系，只需要修改一次李小明对应的系的值即可。——有改进
2. 数据冗余是否减少了？
   学生的姓名、系名与系主任，不再像之前一样重复那么多次了。——有改进
3. 删除某个系中所有的学生记录
   该系的信息仍然全部丢失。——无改进
4. 插入一个尚无学生的新系的信息。
   因为学生表的码是学号，不能为空，所以此操作不被允许。——无改进

所以说，仅仅符合2NF的要求，很多情况下还是不够的，而出现问题的原因，在于仍然存在非主属性**系主任**对于主码**学号**的**传递函数依赖**。为了能进一步解决这些问题，还需要将符合2NF要求的数据表改进为符合3NF的要求。

***

## 第三范式（3NF）

第三范式(Third Normal Form,3rd NF)就是指表中的所有数据元素不但要能惟一地被主关键字所标识，而且它们之间还必须相互独立,不存在其他的函数关系。

**3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖**。也就是说， 如果存在非主属性对于码的传递函数依赖，则不符合3NF的要求。

接下来我们看看上表中的设计，是否符合3NF的要求：

* 对于**选课表**，主码为**（学号，课名）**，主属性为**学号**和**课名，**非主属性只有一个**分数**，不可能存在传递函数依赖，所以**选课**表的设计，符合3NF的要求。
* 对于**学生表**，主码为**学号**，主属性为**学号**，非主属性为**姓名**、**系名**和**系主任**。
  * 因为 学号 → 系名，同时 系名 → 系主任，所以存在非主属性**系主任**对于码**学号**的传递函数依赖，所以**学生**表的设计，不符合3NF的要求。

为了让数据表设计达到3NF，必须进一步进行模式分解为以下形式：

* 选课表（学号，课名，分数）
* 学生表（学号，姓名，系名）
* 系表（系名，系主任）

新的函数依赖关系入下图：

![](https://note-taking-1258869021.cos.ap-beijing.myqcloud.com/SQL/3NF%201.jpg)

模式分解以后新的数据：

![](https://note-taking-1258869021.cos.ap-beijing.myqcloud.com/SQL/3NF%202.jpg)

进行同样的操作，是否还存在着之前的那些问题？

* 删除某个系中所有的学生记录
  该系的信息不会丢失。——有改进
* 插入一个尚无学生的新系的信息。
  因为系表与学生表目前是独立的两张表，所以不影响。——有改进
* 数据冗余更加少了。——有改进

由此可见，符合3NF要求的数据库设计，**基本**上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。当然，在实际中，往往为了性能上或者应对扩展的需要，经常 做到2NF或者1NF，但是作为数据库设计人员，至少应该知道，3NF的要求是怎样的。

***

## BCNF 范式

对于关系模式R，若 R为第一范式，且每个属性都不部分函数依赖于候选码，也不传递函数依赖于候选码，那么称R是BC范式  。

相对于第三范式，BC范式的要求更加严格。第三范式只是要求R为第二范式，且非主属性不传递依赖于R的候选码，而BC范式则是对R的每个属性都做要求。在BCNF中，任何属性（包括非主属性和主属性）都不能被非主属性所决定。

任何一个BCNF必然满足： 

- 所有非主属性都完全函数依赖于每个候选键
- 所有主属性都完全函数依赖于每个不包含它的候选键
- 没有任何属性完全函数依赖于非候选键的任何一组属性

若：

1. 某公司有若干个仓库；
2. 每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作；
3. 一个仓库中可以存放多种物品，一种物品也可以存放在不同的仓库中。每种物品在每个仓库中都有对应的数量。

那么关系模式 仓库（仓库名，管理员，物品名，数量） 属于哪一级范式？

* 已知函数依赖集：仓库名 → 管理员，管理员 → 仓库名，（仓库名，物品名）→ 数量
* 主码：（管理员，物品名），（仓库名，物品名）
* 主属性：仓库名、管理员、物品名
* 非主属性：数量

∵ 不存在非主属性对码的部分函数依赖和传递函数依赖。

∴ 此关系模式属于3NF。

此关系模式的关系如图所示：

![](https://note-taking-1258869021.cos.ap-beijing.myqcloud.com/SQL/4NF%201.jpg)

既然此关系模式已经属于了 3NF，那么这个关系模式是否存在问题呢？来看以下几种操作：

1. 先新增加一个仓库，但尚未存放任何物品，是否可以为该仓库指派管理员？

   ——不可以，因为物品名也是主属性，根据实体完整性的要求，主属性不能为空。

2. 某仓库被清空后，需要删除所有与这个仓库相关的物品存放记录，会带来什么问题？

   ——仓库本身与管理员的信息也被随之删除了。

3. 如果某仓库更换了管理员，会带来什么问题？

   ——这个仓库有几条物品存放记录，就要修改多少次管理员信息。

从这里我们可以得出结论，在某些特殊情况下，即使关系模式符合 3NF 的要求，仍然存在着插入异常，修改异常与删除异常的问题，仍然不是 ”好“ 的设计。

造成此问题的原因：**存在着主属性对于主码的部分函数依赖与传递函数依赖。**

在此例中就是存在：主属性 仓库名 P→（管理员，物品名）。

解决办法就是要在 3NF 的基础上消除主属性对于主码的部分与传递函数依赖。

* 仓库表（仓库名，管理员）
* 库存表（仓库名，物品名，数量）

***

综上：

1、第一范式（1NF）：一个关系模式R的所有属性都是不可分的基本数据项。 

2、第二范式（2NF）：关系模式R属于第一范式，且每个非主属性都完全函数依赖于主码。 

3、第三范式（3NF）：关系模式R属于第二范式，且每个非主属性不存在传递函数依赖。 

4、BC范式（BCNF）：关系模式R属于第三范式，消除表中的多值依赖。

***

参考：

[如何解释关系数据库的第一第二第三范式](https://www.zhihu.com/question/24696366/answer/29189700)，刘慰