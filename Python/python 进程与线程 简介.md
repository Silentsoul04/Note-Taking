简单描述多线程编程涉及的一些术语，大部分引用自wiki。

## 目的

操作系统的设计，可以归结为三点：

1. 以多进程形式，允许多个任务同时运行；
2. 以多线程形式，允许单个任务分成不同的部分运行；
3. 提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。

运行以后的程序叫做"进程"（process），一般情况下，一个进程一次只能执行一个任务。

如果有很多任务需要执行，不外乎三种解决方法。

1. 排队。因为一个进程一次只能执行一个任务，只好等前面的任务执行完了，再执行后面的任务。
2. 新建进程。使用fork命令，为每个任务新建一个进程。
3. 新建线程。因为进程太耗费资源，所以如今的程序往往允许一个进程包含多个线程，由线程去完成任务。

PS：

**并行计算**：parallel computing，一般是指许多指令得以同时进行的计算模式。主要目的是节省大型和复杂问题的解决时间。

**并发计算**：Concurrent computing，将一个计算任务，分割成几个小的部分，让它们同时被计算，之后再汇整计算结果，以完成任务。并发计算是一种程序运算的特性，可以被视为是并行运算的进一步抽象，它包涵了时间片这种可以被用来实现虚拟并行运算的技术。当有多个线程在计算时，如果只有一个 CPU，那么不可能真正同时执行1个以上的线程。系统只能把CPU运行时间划分成若干个时间片，再将时间片分配给各个线程执行。当一个时间片的线程代码运行时，其它线程处于挂起状。

**时间片**：timeslice，是分时操作系统分配给每个正在运行的进程微观上的一段CPU时间。时间片由操作系统内核的调度程序分配给每个进程。首先，内核会给每个进程分配时间片，然后每个进程轮番地执行相应的时间，当所有进程都处于时间片耗尽的状态时，内核会重新为每个进程计算并分配时间片，如此往复。 

**分时**：time-sharing，是对计算机资源的一种共享方式，利用多道程序与多任务处理使多个用户可以同时使用一台计算机。一般来说，计算机用户（可以是多个）通过特定的端口向计算机发送指令，计算机完成相应任务后再将结果通过端口反馈给用户。 计算机处理多个用户发送出的指令的时候，处理的方案即为分时，即计算机把它的运行时间分为多个时间片，并且将这些时间段平均分配给用户们指定的任务。轮流地为每一个任务运行一定的时间，如此循环，直至完成所有任务。 

**多任务处理**：Computer multitasking，是指计算机同时运行多个程序的能力。多任务的一般方法是运行第一个程序的一段代码，保存工作环境；再运行第二个程序的一段代码，保存环境；……恢复第一个程序的工作环境，执行第一个程序的下一段代码……现代的多任务，每个程序的时间分配相对平均。

**多道程序**： multiprogramming，多道程序是令CPU一次读取多个程序放入内存，先运行第一个程序直到它出现了IO操作。因为IO操作慢，CPU需要等待。为了提高CPU利用率，此时运行第二个程序。即，第n+1个程序得以执行的条件是第n个程序进行IO操作或已经运行完毕。这种方式每个程序的时间分配是不均等的，很可能第一个程序运行了几个小时而不出现IO操作，故第二个程序没有运行。 

***

## 进程和线程

### 进程

process，是指计算机中已运行的程序。用户下达运行程序的命令后，就会产生进程。同一程序可产生多个进程（一对多关系），以允许同时有多位用户运行同一程序，却不会相冲突。 

每个进程都提供执行程序所需的所有资源，都有一个虚拟的地址空间、可执行的代码、操作系统的接口、安全的上下文（记录启动该进程的用户和权限等等）、唯一的进程ID、环境变量、优先级类、最小和最大的工作空间（内存空间）。进程可以包含线程，并且每个进程必须有至少一个线程。每个进程启动时都会最先产生一个线程，即主线程，然后主线程会再创建其他的子线程。

在面向线程设计的系统（如当代多数操作系统、Linux 2.6及更新的版本）中，进程本身不是基本运行单位，而是线程的容器。程序本身只是指令、数据及其组织形式的描述，进程才是程序（那些指令和数据）的真正运行实例。

进程在运行时，状态（*state*）会改变。所谓状态，就是指进程目前的动作： 

- 新生（*new*）：进程新产生中。
- 运行（*running*）：正在运行。
- 等待（*waiting*）：等待某事发生，例如等待用户输入完成。亦称“阻塞”（*blocked*）
- 就绪（*ready*）：排班中，等待CPU。
- 结束（*terminated*）：完成运行。

各状态名称可能随不同操作系统而相异；对于单CPU系统（UP），任何时间可能有多个进程为等待、就绪，但必定仅有一个进程在运行。 

### 线程

thread，是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。一个进程可以有很多线程，每条线程并行执行不同的任务。

操作系统能够进行运算调度的最小单位。同一个进程内，线程共享进程空间的任务单位，但有各自的调用栈（call stack），自己的寄存器环境（register context），自己的线程本地存储（thread-local storage）。另外，线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不独立拥有系统资源，但它可与同属一个进程的其它线程共享该进程所拥有的全部资源。每一个应用程序都至少有一个进程和一个线程。线程切换需要内核切换上下文。在单个程序中同时运行多个线程完成不同的被划分成一块一块的工作，称为多线程。

在多核或多CPU，或支持Hyper-threading的CPU上使用多线程程序设计的好处是显而易见，即提高了程序的执行吞吐率。在单CPU单核的计算机上，使用多线程技术，也可以把进程中负责I/O处理、人机交互而常被阻塞的部分与密集计算的部分分开来执行，编写专门的workhorse线程执行密集计算，从而提高了程序的执行效率。 

线程有四种基本状态，分别为： 

- 产生（spawn）
- 中断（block）
- 非中断（unblock）
- 结束（finish）

#### 多线程

multithreading，是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。具有这种能力的系统包括对称多处理机、多核心处理器以及芯片级多处理（Chip-level multithreading）或同时多线程（Simultaneous multithreading）处理器。

每一个线程都代表一个进程内的一个独立执行上下文。

* 软件多线程。即便处理器只能运行一个线程，操作系统也可以通过快速的在不同线程之间进行切换，由于时间间隔很小，来给用户造成一种多个线程同时运行的假象。这样的程序运行机制被称为软件多线程。
* 硬件多线程技术。具有多个处理器，所以具有真正的同时执行多个线程的能力。

进程是由若干线程组成的，一个进程至少有一个线程。由于任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程，这些新的线程可以成为子线程。

当一个程序启动时，就有一个进程被操作系统（OS）创建，与此同时一个线程也立刻运行，该线程通常叫做程序的主线程（Main Thread），因为它是程序开始时就执行的。如果再创建新的线程，那么创建的线程就是这个主线程的子线程。每个进程至少都有一个主线程，在Winform中，应该就是创建GUI的线程。

主线程的重要性体现在两方面：

* 产生其他子线程的线程
* 通常它必须最后完成执行比如执行各种关闭动作

#### 多线程 vs 多进程

进程是系统资源分配的最小单位，线程是程序执行的最小单位。

- 同一个进程中的线程共享同一内存空间，但进程之间的内存空间是独立的。
- 同一个进程中的所有线程的数据是共享的，但进程之间的数据是独立的。
- 对主线程的修改可能会影响其他线程的行为，但是父进程的修改（除了删除以外）不会影响其他子进程。
- 线程是一个上下文的执行指令，而进程则是与运算相关的一簇资源。
- 同一个进程的线程之间可以直接通信，但是进程之间的交流需要借助中间代理来实现。
- 创建新的线程很容易，但是创建新的进程需要对父进程做一次复制。
- 一个线程可以操作同一进程的其他线程，但是进程只能操作其子进程。
- 线程启动速度快，进程启动速度慢（但是两者运行速度没有可比性）。

多进程模式最大的优点就是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程。（当然主进程挂了所有进程就全挂了，但是Master进程只负责分配任务，挂掉的概率低）著名的Apache最早就是采用多进程模式。

多进程模式的缺点是创建进程的代价大，在Unix/Linux系统下，用`fork`调用还行，在Windows下创建进程开销巨大。另外，操作系统能同时运行的进程数也是有限的，在内存和CPU的限制下，如果有几千个进程同时运行，操作系统连调度都会成问题。

多线程模式通常比多进程快一点，但是也快不到哪去，而且，多线程模式致命的缺点就是任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存。在Windows上，如果一个线程执行的代码出了问题，你经常可以看到这样的提示：“该程序执行了非法操作，即将关闭”，其实往往是某个线程出了问题，但是操作系统会强制结束整个进程。

在Windows下，多线程的效率比多进程要高，所以微软的IIS服务器默认采用多线程模式。由于多线程存在稳定性的问题，IIS的稳定性就不如Apache。为了缓解这个问题，IIS和Apache现在又有多进程+多线程的混合模式，真是把问题越搞越复杂。

Python中想要充分利用多核CPU，就用多进程。因为每个进程有各自独立的GIL，互不干扰，这样就可以真正意义上的并行执行。在Python中，多进程的执行效率优于多线程(仅仅针对多核CPU而言)。同时建议在IO密集型任务中使用多线程，在计算密集型任务中使用多进程。

PS:

**数据-程序依赖**：program-data dependence），是一种软件数据相互关系。具体指一旦某个应用程序改变了，相应的数据也要随之改变。各种不同的传统计算机程序需要定义数据的位置和属性。在传统的文件环境里，软件程序的改变要求对于需要访问的数据也做相应的改变。 

***

## GIL

Global Interpreter Lock，缩写GIL。GIL 是计算机程序设计语言解释器用于同步线程的一种机制，它使得任何时刻仅有一个线程在执行。即便在多核心处理器上，使用 GIL 的解释器也只允许同一时间执行一个线程。互斥锁来限制线程对共享资源的访问，解决多线程之间数据完整性和状态同步的最简单方法自然就是加锁。GIL的存在导致多线程无法很好的立即多核CPU的处理能力，使得操作系统线程调度的这个本来就昂贵的操作变得更奢侈了。

同一时刻只有一个线程能够运行，那么是怎么执行多线程程序的呢？其实原理很简单：解释器的分时复用。即多个线程的代码，轮流被解释器执行，只不过切换的很频繁很快，给人一种多线程“同时”在执行的错觉。聊的学术化一点，其实就是“并发”。

普通解释：
并发：交替做不同事情的能力
并行：同时做不同事情的能力
专业术语：
并发：不同的代码块交替执行
并行：不同的代码块同时执行

### Python的GIL

Python最初的设计理念在于，为了解决多线程之间数据完整性和状态同步的问题，设计为在任意时刻只有一个线程在解释器中运行。而当执行多线程程序时，由GIL来控制同一时刻只有一个线程能够运行。即Python中的多线程是表面多线程，也可以理解为fake多线程，不是真正的多线程。

虽然CPython的线程库直接封装了系统的原生线程，但CPython整体作为一个进程，同一时间只会有一个获得GIL的线程在跑，其他线程则处于等待状态。这就造成了即使在多核CPU中，多线程也只是做着分时切换而已。

如果程序是CPU密集型，多个线程的代码很有可能是线性执行的。所以这种情况下多线程是鸡肋，效率可能还不如单线程因为有上下文切换开销。但是如果代码是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，多线程可以明显提高效率，例如多线程爬虫，多线程文件处理等等

* CPython的线程是操作系统的原生线程。在Linux上为pthread，在Windows上为Win thread，完全由操作系统调度线程的执行。一个Python解释器进程内有一个主线程，以及多个用户程序的执行线程。即便使用多核心CPU平台，由于GIL的存在，也将禁止多线程的并行执行。
* Python解释器进程内的多线程是以协作多任务方式执行。当一个线程遇到I/O任务时，将释放GIL。
* 可以创建独立的进程来实现并行化。Python 2.6引进了多进程包multiprocessing。或者将关键组件用C/C++编写为Python扩展，通过ctypes使Python程序直接调用C语言编译的动态链接库的导出函数。
* Python 3.2开始使用新的GIL。新的GIL实现中用一个固定的超时时间来指示当前的线程放弃全局锁。

### GIL对python的影响

GIL的优点是显而易见的，GIL可以保证我们在多线程编程时，无需考虑多线程之间数据完整性和状态同步的问题。GIL缺点是：我们的多线程程序执行起来是“并发”，而不是“并行”。因此执行效率会很低，会不如单线程的执行效率。

GIL 的存在使程序无法充分利用CPU进行运算。

* 同一时刻有且只有一个线程会执行
* 多个线程由于GIL锁的存在无法利用多核CPU
* 多线程不适合计算机密集型的程序
* 如果程序需要大量的计算，利用多核CPU资源，可以使用多进程来解决

### 计算密集型和IO密集型

可以把任务分为计算密集型和IO密集型：

- 计算密集型任务的特点是要进行大量的计算，消耗CPU资源，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。

  计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。

- IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。

  IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。

  密集进行输入/输出（I/O）操作的应用程序，多数的时间，都在等待输入或输出操作完成。在等待的时间中，并发计算编程可以让另外的进程来运作。

Python的多线程在多核CPU上，只对于IO密集型计算产生正面效果；而当有至少有一个CPU密集型线程存在，那么多线程效率会由于GIL而大幅下降。

```python
import time
from concurrent.futures import ThreadPoolExecutor, as_completed
from concurrent.futures import ProcessPoolExecutor


def fib(n):
    if n<=2:
        return 1
    return fib(n-1)+fib(n-2)

def test(pool):
    with pool as executor:
        all_tast = [executor.submit(fib, (num)) for num in range(30, 35)]
        start = time.time()
        for future in as_completed(all_tast):
            data = future.result()
            print('Result:', data)
        end = time.time()
        print('{} cost:{}'.format(str(pool).split('.')[2], end-start))

if __name__ == "__main__":
    test(ThreadPoolExecutor(3))		# thread cost:3.8875913619995117
    test(ProcessPoolExecutor(3))	# process cost:2.77000093460083
```

### 如何规避GIL带来的影响

用multiprocess（多进程）替代Thread（推荐）。每个进程有自己的独立的GIL，因此也不会出现进程之间的GIL争抢。但，它的引入会增加程序实现时线程间数据通讯和同步的困难。

因为GIL的存在，只有IO Bound场景下得多线程会得到较好的性能。

如果对并行计算性能较高的程序可以考虑把核心部分也成C模块，或者索性用其他语言实现。

***

## 新旧 GIL

在 python32 版本，对 GIL 进行重写，多线程得到了改善。

可参考：[Python 3.2 - GIL - good/bad?](https://stackoverflow.com/questions/3384385/python-3-2-gil-good-bad)

* Past versions of Python kept track of interpreter instructions and "ticks".Once a certain number of ticks had executed, a thread-switch signal was sent
* New GIL is time-based (more in a second)

### python27

```python
# coding=utf-8
import time
from threading import Thread

def profile(func):
    def wrapper(*args, **kwargs):
        import time
        start = time.time()
        func(*args, **kwargs)
        end   = time.time()
        print('COST: {}'.format(end - start))
    return wrapper


def count(n):
    while n > 0:
        n -= 1

@profile
def no_thread():
    count(100000000)
    count(100000000)

@profile
def two_thread():
    t1 = Thread(target=count,args=(100000000,))
    t1.start()
    t2 = Thread(target=count,args=(100000000,))
    t2.start()
    t1.join()
    t2.join()

if __name__ == '__main__':
    one_thread()	# 9.68400001526
    two_thread()	# 26.8359999657
```

### python37

```python
# coding=utf-8
import time
from threading import Thread

def profile(func):
    def wrapper(*args, **kwargs):
        import time
        start = time.time()
        func(*args, **kwargs)
        end   = time.time()
        print('COST: {}'.format(end - start))
    return wrapper


def count(n):
    while n > 0:
        n -= 1

@profile
def no_thread():
    count(100000000)
    count(100000000)

@profile
def two_thread():
    t1 = Thread(target=count,args=(100000000,))
    t1.start()
    t2 = Thread(target=count,args=(100000000,))
    t2.start()
    t1.join()
    t2.join()

if __name__ == '__main__':
    one_thread()	# 12.299971580505371
    two_thread()	# 12.311794757843018
```

***

参考：

wiki

[进程 vs. 线程](https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014319292979766bd3285c9d6b4942a8ea9b4e9cfb48d8000)

http://www.liujiangblog.com/course/python/78

https://www.cnblogs.com/ArsenalfanInECNU/p/9968621.html

http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html