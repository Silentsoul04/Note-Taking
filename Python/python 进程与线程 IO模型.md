## 相关概念

**阻塞**：调用函数的时候，当前线程被挂起。程序在等待操作完成期间，自身无法继续干别的事情。常见的阻塞形式有网络I/O阻塞，磁盘I/O阻塞，用户输入阻塞，CPU阻塞等等。

**非阻塞**：调用函数的时候，立即返回，当前线程不会被挂起。程序在等待某操作过程中，自身不被阻塞，可以继续运行干别的事情。

这里我们就会看到非阻塞并不是在任何程序级别、任何情况下都是存在的。例如在单个函数的级别，上一行是向磁盘索取文件，下一行是对文件内容进行运算，那么当磁盘I/O未有结果时，是无法继续下一行的，此时这个函数是不可能存在非阻塞的状态的。

只有当程序单元高到了一定级别，它可以囊括独立的子程序单元，它才可能有非阻塞状态的存在。因为阻塞的操作都在子程序单元中，阻塞的是子程序单元而不会阻塞它本身。例如一个单进程多线程的文件操作程序，某个线程在操作一个文件时阻塞了，而别的线程还可以继续运行下去，该进程本身还是运行态而非阻塞态，所以该文件操作程序是非阻塞的。

**阻塞VS非阻塞**：

阻塞和非阻塞关注的是**程序在等待调用结果（消息，返回值）时的状态**.

阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。

由上可知，在计算机程序的世界里，阻塞是绝对的，非阻塞是相对的。

**同步**：指各个任务按顺序一个接一个执行，协调一致，某个任务结束之前，并不会开始其它任务。

同步异步的概念是针对至少两个程序单元而言（可以是同级别的，也可以是不同级别的程序单元）。

**异步**：是指一个任务的执行流程（任务开始、运行和结束）独立于其它任务，并不会阻塞其它任务（其它任务无
需等待该任务执行结束）。

真正意义上的异步是比较少的。而我们常见的技术文档中所提到的异步，是指多个相干的程序单元，其中一个对另一个有依赖，发起请求的程序单元不必等待另一个完成所有的需求就得到了一个临时的返回结果，而请求方真正需要的数据是稍后再返回给请求方。为了解耦程序单元之间的直接关系，所以常常引入了第三者，即是所谓的异步框架或者异步机制。

常见的异步机制有回调、事件循环、信号量等，它们也常常会相互结合使用。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。

**同步VS异步**：

同步和异步关注的是**消息通信机制 (synchronous communication/ asynchronous communication)**

所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由调用者**主动**等待这个调用的结果，同步只能让调用者去轮询调用的结果。

而异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来**通知**调用者，或通过回调函数处理这个调用。

由上述可知，现在大多数文档或者大家所说的异步，其主要目的其实是为了让请求方不必为了该次请求而阻塞以提高请求方的工作效率，所以非阻塞与异步两词就如孪生兄弟般形影不离甚至出现了相互代替的现象。 我们也可以得知，绝大多数时候，程序单元的级别能够囊括独立子程序单元的情况下，才会有所谓的异步，比如要借助多协程、多线程、多进程来实现异步程序。

同步和异步仅仅是关于所关注的消息如何通知的机制。同步的情况下，是由处理消息者自己主动等待消息是否被触发，而异步的情况下是由触发机制来通知处理消息者
阻塞和非阻塞应该是发生在消息的处理的时刻。阻塞其实就是等待，发出通知，等待结果完成。非阻塞属于发出通知，立即返回结果，没有等待过程。

在不同层次，四者的关系：

**CPU层次**
在CPU层次，或者说操作系统进行IO和任务调度的层次，现代操作系统通常使用异步非阻塞方式进行IO（有少部分IO可能会使用同步非阻塞轮询），即发出IO请求之后，并不等待IO操作完成，而是继续执行下面的指令（非阻塞），**IO操作和CPU指令互不干扰（异步）**，最后通过中断的方式来通知IO操作完成结果。

**线程层次**

在线程层次，或者说操作系统调度单元的层次，操作系统为了减轻程序员的思考负担，将底层的异步非阻塞的IO方式进行封装，把相关系统调用（如read，write等）以同步的方式展现出来。然而，**同步阻塞的IO会使线程挂起，同步非阻塞的IO会消耗CPU资源在轮询**。为了解决这一问题，就有3种思路：

1. 多线程（同步阻塞）；
2. IO多路复用（select，poll，epoll）（同步非阻塞，严格地来讲，是把阻塞点改变了位置）；
3. 直接暴露出异步的IO接口，如kernel-aio和IOCP（异步非阻塞）。

**程序员感知层次**
在Linux中，上面提到的第2种思路用得比较广泛，也是比较理想的解决方案。然而，直接使用select之类的接口，依然比较复杂，所以各种库和框架百花齐放，都试图对IO多路复用进行封装。此时，库和框架提供的API又可以选择是以同步的**方式**还是异步的**方式**来展现。如python的asyncio库中，就通过协程，提供了同步阻塞式的API；如node.js中，就通过回调函数，提供了异步非阻塞式的API。

因此，我们在讨论同步、异步、阻塞、非阻塞时，必须先明确是在哪个层次进行讨论。比如node.js，我们可以说她在程序员感知层次提供了异步非阻塞的API，也可以说在Linux下，她在线程层次以同步非阻塞的epoll来实现。

***

## 5种类UNIX下可用的I/O模型：

**用户空间和内核空间**

操作系统都是采用虚拟存储器，对于32位操作系统，它的寻址空间（虚拟存储空间）为4G。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护内存空间，也有访问底层硬件设备的所有权限，为了保证用户进程不能直接操作内核，保证内核的安全，操作系统将虚拟空间分为两部分：一部分为内核空间，一部分是用户空间，针对linux系统而言，将最高的1G字节给内核使用，称为内核空间，将3G字节的供各个进程使用，称为用户空间

**文件描述符fd**

文件描述符是一个用于表述指向文件的引用的抽象化概念

文件描述符在形式上是一个非负整数，实际上，它是一个索引值，指内核为每一个进程所维护的进程打开文件的记录的记录表，当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。

**缓存IO**

缓存IO，也被称为标准IO，大多数文件系统默认IO操作都是缓存IO，在Linux的缓存IO机制中，操作系统会将IO的数据缓存在文件系统的页缓存（page  cache）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间

缓存IO的缺点：数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的CPU以及内存开销是非常大的。

***

对于一次IO访问（以read为例子），数据会先拷贝到操作系统内核的缓冲区中，然后会从操作系统内核的缓冲区拷贝到应用程序的地址空间，也就是说当一个read操作发生时，它会经历两个阶段：

1. 等待数据准备
2. 经数据从内核拷贝到进程

正是因为这两个阶段，linux系统产生了五种网络模式的方案：

1. 阻塞I/O（blocking IO）

2. 非阻塞I/O（nonblocking IO）

3. I/O多路复用（IO multiplexing）

4. 信号驱动I/O（signal driven IO）

5. 异步I/O（asynchromous IO）

注意：信号驱动I/O（signal driven IO）在实际中不常用。

每个 I/O 模型都有自己的使用模式，它们对于特定的应用程序都有自己的优点。

### 阻塞式 I/O

默认情况下，所有套接字都是阻塞的。

当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：

1. 准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。这个时候kernel就要等待足够的数据到来）。数据被拷贝到操作系统内核的缓冲区中是需要一个过程，这个过程需要等待。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。
2. 当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。

![](https://note-taking-1258869021.cos.ap-beijing.myqcloud.com/python/thread%20process%20IO-blocking.png)

直到阻塞结束recvfrom才能返回。

### 非阻塞式 I/O

linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：

当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。

![](https://note-taking-1258869021.cos.ap-beijing.myqcloud.com/python/thread%20process%20IO-non-blocking.png)

可以看出recvfrom总是立即返回。

### I/O 多路复用

虽然I/O多路复用的函数也是阻塞的，但是其与以上两种还是有不同的，I/O多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I/O系统调用如recvfrom之上。会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。如图：

![](https://note-taking-1258869021.cos.ap-beijing.myqcloud.com/python/thread%20process%20IO-multiplexing.png)

当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。 

这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和  recvfrom)，而blocking IO只调用了一个system call  (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。

所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading +  blocking IO的web  server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）

I/O multiplexing 这里面的 multiplexing 指的其实是在**单个线程**通过记录跟踪每一个Sock(I/O流)的状态(对应空管塔里面的Fight progress strip槽)来同时管理多个I/O流. 发明它的原因，是尽量多的**提高**服务器的吞吐能力。多路网络连接复用一个io线程。

![](https://note-taking-1258869021.cos.ap-beijing.myqcloud.com/python/thread%20process%20IO-multiplexing-1.jpg)

在IO multiplexing  Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket  IO给block。

### 信号驱动式 I/O

用的很少，就不做讲解了。

### 异步 I/O

这类函数的工作机制是告知内核启动某个操作，并让内核在整个操作（包括将数据从内核拷贝到用户空间）完成后通知我们。用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。回调就是用来处理此时返回的结果。

![](https://note-taking-1258869021.cos.ap-beijing.myqcloud.com/python/thread%20process%20IO-asynchronous.png)

调用时就可以立马返回，等函数操作完成会通知我们。

### 总结

 其实前四种I/O模型都是同步I/O操作，他们的区别在于第一阶段，而他们的第二阶段是一样的：在数据从内核复制到应用缓冲区期间（用户空间），进程阻塞于recvfrom调用。相反，异步I/O模型在这两个阶段都要处理。

![](https://note-taking-1258869021.cos.ap-beijing.myqcloud.com/python/thread%20process%20IO5.png)

**blocking IO**的特点就是在IO执行的两个阶段都被block了

**nonblocking IO**的特点是用户进程在内核准备数据的阶段需要不断主动询问kernel数据好了没有

**IO multiplexing**的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。

再看POSIX对这两个术语的定义：

- 同步I/O操作：导致请求进程阻塞，直到I/O操作完成；
- 异步I/O操作：不导致请求进程阻塞。

好，下面我用我的语言来总结一下阻塞，非阻塞，同步，异步

- 阻塞，非阻塞：进程/线程要访问的数据是否就绪，进程/线程是否需要等待；
- 同步，异步：访问数据的方式，同步需要主动读写数据，在读写数据的过程中还是会阻塞；异步只需要I/O操作完成的通知，并不主动读写数据，由操作系统内核完成数据的读写。

**异步VS非阻塞 IO**：二者没有必然关系：前者指任务间的关系，而后者是一项 IO 技术，两者不是同一层次的
概念。但是异步和非阻塞一般被认为是两个可互换使用的词汇 - 因为异步流程之间并不会相互阻塞。

在处理 IO 的时候，阻塞和非阻塞都是同步 IO。只有使用了特殊的 API 才是异步 IO。

![](https://note-taking-1258869021.cos.ap-beijing.myqcloud.com/python/thread%20process%20IO-1.jpg)

I/O复用(select/poll/epoll)都属于同步I/O，因为它们在数据由内核空间复制回进程缓冲区时都是阻塞的(不能干别的事)。只有异步I/O模型(AIO)是符合异步I/O操作的含义的，即在1）数据准备完成、2）由内核空间拷贝回缓冲区后，通知进程，在等待通知的这段时间里可以干别的事。

而异步 IO一般指 IO 读写操作由独立执行流程（a thread of execution）完成，随后将数据交给其它执行流程。

要支持并发，必须拆分为多任务，不同任务相对而言才有阻塞/非阻塞、同步/异步。所以，并发、异步、非阻塞三个词总是如影随形。

***

参考：

https://www.zhihu.com/question/19732473

http://www.cnblogs.com/zhaof/p/5932461.html

https://www.zhihu.com/question/32163005