## 阻塞、非阻塞、同步、异步间

阻塞/非阻塞， 同步/异步的概念要注意讨论的上下文。

### 应用层级

**阻塞VS非阻塞**：

阻塞和非阻塞关注的是**程序在等待调用结果（消息，返回值）时的状态**.

- **阻塞调用**：调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。程序在等待操作完成期间，自身无法继续干别的事情。
- **非阻塞调用**：调用函数的时候，立即返回，当前线程不会被挂起。在不能立刻得到结果之前，该调用不会阻塞当前线程。程序在等待某操作过程中，自身不被阻塞，可以继续运行干别的事情。

这里我们就会看到非阻塞并不是在任何程序级别、任何情况下都是存在的。例如在单个函数的级别，上一行是向磁盘索取文件，下一行是对文件内容进行运算，那么当磁盘I/O未有结果时，是无法继续下一行的，此时这个函数是不可能存在非阻塞的状态的。

只有当程序单元高到了一定级别，它可以囊括独立的子程序单元，它才可能有非阻塞状态的存在。因为阻塞的操作都在子程序单元中，阻塞的是子程序单元而不会阻塞它本身。例如一个单进程多线程的文件操作程序，某个线程在操作一个文件时阻塞了，而别的线程还可以继续运行下去，该进程本身还是运行态而非阻塞态，所以该文件操作程序是非阻塞的。

由上可知，在计算机程序的世界里，阻塞是绝对的，非阻塞是相对的。

**同步VS异步**：

同步和异步关注的是**消息通信机制 (synchronous communication/ asynchronous communication)**

* **同步**：发出一个调用时，没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由调用者**主动**等待这个调用的结果，同步只能让调用者去轮询调用的结果。各个任务按顺序一个接一个执行，某个任务结束之前，并不会开始其它任务。

* **异步**：则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来**通知**调用者，或通过回调函数处理这个调用。一个任务的执行流程（任务开始、运行和结束）独立于其它任务，其它任务无需等待该任务执行结束。

真正意义上的异步是比较少的。而我们常见的技术文档中所提到的异步，是指多个相干的程序单元，其中一个对另一个有依赖，发起请求的程序单元不必等待另一个完成所有的需求就得到了一个临时的返回结果，而请求方真正需要的数据是稍后再返回给请求方。为了解耦程序单元之间的直接关系，所以常常引入了第三者，即是所谓的异步框架或者异步机制。

常见的异步机制有回调、事件循环、信号量等，它们也常常会相互结合使用。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。

### 进程间通信层级

进程间的通信是通过 send() 和 receive() 两种基本操作完成的。具体如何实现这两种基础操作，存在着不同的设计。  消息的传递有可能是**阻塞的**或**非阻塞的** – 也被称为**同步**或**异步**的。

* 阻塞式发送（blocking send）：发送方进程会被一直阻塞， 直到消息被接受方进程收到
* 非阻塞式发送（nonblocking send）：发送方进程调用 send() 后， 立即就可以其他操作
* 阻塞式接收（blocking receive）：接收方调用 receive() 后一直阻塞， 直到消息到达可用
* 非阻塞式接受（nonblocking receive）：接收方调用 receive() 函数后， 要么得到一个有效的结果， 要么得到一个空值， 即不会被阻塞。

上述不同类型的发送方式和不同类型的接收方式，可以自由组合。也就是说， 从进程级通信的维度讨论时， 阻塞和同步（非阻塞和异步）就是一对同义词， 且需要针对**发送方**和**接收方**作区分对待。

#### 用户空间和内核空间

操作系统为了支持多个应用同时运行，需要保证不同进程之间相对独立（一个进程的崩溃不会影响其他的进程 ， 恶意进程不能直接读取和修改其他进程运行时的代码和数据）。 因此操作系统内核**需要拥有高于普通进程的权限**， 以此来调度和管理用户的应用程序。

于是内存空间被划分为两部分，一部分为内核空间，一部分为用户空间。内核空间存储的代码和数据具有更高级别的权限。内存访问的**相关硬件**在程序执行期间会进行访问控制（ Access Control），使得用户空间的程序不能直接读写内核空间的内存。

举例说明：操作系统都是采用虚拟存储器，对于32位操作系统，它的寻址空间（虚拟存储空间）为4G。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护内存空间，也有访问底层硬件设备的所有权限，为了保证用户进程不能直接操作内核，保证内核的安全，操作系统将虚拟空间分为两部分：一部分为内核空间，一部分是用户空间，针对linux系统而言，将最高的1G字节给内核使用，称为内核空间，将3G字节的供各个进程使用，称为用户空间。

#### 进程切换

![](https://note-taking-1258869021.cos.ap-beijing.myqcloud.com/python/thread%20process%20IO%20OS.jpg)

上图展示了进程切换中几个最重要的步骤：

* 当一个程序正在执行的过程中， 中断（interrupt） 或 系统调用（system call） 发生可以使得 CPU 的控制权会从当前进程转移到操作系统内核。
* 操作系统内核负责保存进程 i 在 CPU 中的上下文（程序计数器， 寄存器）到 PCBi （操作系统分配给进程的一个内存块）中。
* 从 PCBj 取出进程 j 的CPU 上下文， 将 CPU 控制权转移给进程 j ， 开始执行进程 j 的指令。

几个底层概念的通俗（不严谨）解释：

**中断**（interrupt）：CPU 微处理器有一个中断信号位， 在每个CPU时钟周期的末尾, CPU会去检测那个中断信号位是否有中断信号到达， 如果有， 则会根据中断优先级决定是否要暂停当前执行的指令， 转而去执行处理中断的指令。 （其实就是 CPU 层级的 while 轮询）

**时钟中断**（Clock Interrupt） )：一个硬件时钟会每隔一段（很短）的时间就产生一个中断信号发送给 CPU，CPU 在响应这个中断时， 就会去执行操作系统内核的指令， 继而将 CPU 的控制权转移给了操作系统内核， 可以由操作系统内核决定下一个要被执行的指令。

**系统调用**（system call）：system call 是操作系统提供给应用程序的接口。 用户通过调用 systemcall 来完成那些需要操作系统内核进行的操作， 例如硬盘， 网络接口设备的读写等。

从上述描述中， 可以看出来， 操作系统在进行进切换时，需要进行一系列的内存读写操作， 这带来了一定的开销。

#### 进程阻塞



![](https://note-taking-1258869021.cos.ap-beijing.myqcloud.com/python/thread%20process%20IO%20OS-1.jpg)

上图展示了一个进程的不同状态：

- New：进程正在被创建
- Running：进程的指令正在被执行
- Waiting：进程正在等待一些事件的发生（例如 I/O 的完成或者收到某个信号）
- Ready：进程在等待被操作系统调度
- Terminated：进程执行完毕（可能是被强行终止的）

我们所说的 “阻塞”是指进程在**发起了一个系统调用**（System Call） 后， 由于该系统调用的操作不能立即完成，需要等待一段时间，于是内核将进程挂起为**等待 （waiting）**状态， 以确保它不会被调度执行， 占用 CPU 资源。

NOTE： 在任意时刻， 一个 CPU 核心上（processor）只可能运行一个进程 。

### I/O System Call 层级

在 IO 系统调用层面（ IO system call ）层面， **非阻塞 IO 系统调用** 和 **异步 IO 系统调用**存在着一定的差别， 它们都不会阻塞进程， 但是返回结果的方式和内容有所差别， 但是都属于非阻塞系统调用（ non-blocing system call ）

**阻塞和非阻塞**描述的是进程的一个操作是否会使得进程转变为“等待”的状态， 但是为什么我们总是把它和 IO 连在一起讨论呢？

原因是， **阻塞**这个词是与系统调用 System Call 紧紧联系在一起的， 因为要让一个进程进入 等待（waiting） 的状态, 要么是它主动调用 wait() 或 sleep() 等挂起自己的操作， 另一种就是它调用 System Call, 而 System Call 因为涉及到了 I/O 操作， 不能立即完成， 于是内核就会先将该进程置为等待状态， 调度其他进程的运行， 等到 它所请求的 I/O 操作完成了以后， 再将其状态更改回 ready 。

操作系统内核在执行 System Call 时， CPU 需要与 IO 设备完成一系列物理通信上的交互， 其实再一次会涉及到阻塞和非阻塞的问题， 例如， 操作系统发起了一个读硬盘的请求后， 其实是向硬盘设备通过总线发出了一个请求，它即可以阻塞式地等待IO 设备的返回结果，也可以非阻塞式的继续其他的操作。 在现代计算机中，这些物理通信操作基本都是异步完成的， 即发出请求后， 等待 I/O 设备的中断信号后， 再来读取相应的设备缓冲区。 但是，大部分操作系统默认为用户级应用程序提供的都是阻塞式的系统调用 （blocking systemcall）接口， 因为阻塞式的调用，使得应用级代码的编写更容易（代码的执!行顺序和编写顺序是一致的）。

但同样， 现在的大部分操作系统也会提供非阻塞I/O 系统调用接口（Nonblocking I/O system call）。 一个非阻塞调用不会挂起调用程序， 而是会立即返回一个值， 表示有多少bytes 的数据被成功读取（或写入）。

非阻塞I/O 系统调用( nonblocking system call )的另一个替代品是 **异步I/O系统调用 （asychronous system call）**。 与非阻塞 I/O 系统调用类似，asychronous system call 也是会立即返回， 不会等待 I/O 操作的完成， 应用程序可以继续执行其他的操作， 等到 I/O 操作完成了以后，操作系统会通知调用进程（设置一个用户空间特殊的变量值 或者 触发一个 signal 或者 产生一个软中断 或者 调用应用程序的回调函数）。

**非阻塞I/O 系统调用( nonblocking system call )** 和 **异步I/O系统调用 （asychronous system call）**的区别是：

- 一个**非阻塞I/O 系统调用 read()** 操作立即返回的是任何可以立即拿到的数据， 可以是完整的结果， 也可以是不完整的结果， 还可以是一个空值。
- 而**异步I/O系统调用** read（）结果必须是完整的， 但是这个操作完成的通知可以延迟到将来的一个时间点。

下图展示了同步I/O 与 异步 I/O 的区别 （非阻塞 IO 在下图中没有绘出）.  

![](https://note-taking-1258869021.cos.ap-beijing.myqcloud.com/python/thread%20process%20IO%20OS-2.jpg)

上面提到的 **非阻塞I/O 系统调用( nonblocking system call )** 和 **异步I/O系统调用** 都是非阻塞式的行为（non-blocking behavior）。 他们的差异仅仅是返回结果的方式和内容不同。

总结：

在CPU层次，或者说操作系统进行IO和任务调度的层次，现代操作系统通常使用异步非阻塞方式进行IO（有少部分IO可能会使用同步非阻塞轮询），即发出IO请求之后，并不等待IO操作完成，而是继续执行下面的指令（非阻塞），IO操作和CPU指令互不干扰（异步），最后通过中断的方式来通知IO操作完成结果。

在线程层次，或者说操作系统调度单元的层次，操作系统为了减轻程序员的思考负担，将底层的异步非阻塞的IO方式进行封装，把相关系统调用（如read，write等）以同步的方式展现出来。然而，同步阻塞的IO会使线程挂起，同步非阻塞的IO会消耗CPU资源在轮询。

为了解决这一问题，就有3种思路：

1. 多线程（同步阻塞）；
2. IO多路复用（select，poll，epoll）（同步非阻塞，严格地来讲，是把阻塞点改变了位置）；
3. 直接暴露出异步的IO接口，如kernel-aio和IOCP（异步非阻塞）。

非阻塞系统调用（non-blocking I/O system call 与 asynchronous I/O system call） 的存在可以用来实现线程级别的 I/O 并发， 与通过多进程实现的 I/O 并发相比可以减少内存消耗以及进程切换的开销。

然而，直接使用select之类的接口，依然比较复杂，所以各种库和框架百花齐放，都试图对IO多路复用进行封装。此时，库和框架提供的API又可以选择是以同步的**方式**还是异步的**方式**来展现。如python的asyncio库中，就通过协程，提供了同步阻塞式的API；如node.js中，就通过回调函数，提供了异步非阻塞式的API。

因此，我们在讨论同步、异步、阻塞、非阻塞时，必须先明确是在哪个层次进行讨论。比如node.js，我们可以说她在程序员感知层次提供了异步非阻塞的API，也可以说在Linux下，她在线程层次以同步非阻塞的epoll来实现。

***

## 5种类UNIX下可用的I/O模型：

**文件描述符fd**

文件描述符是一个用于表述指向文件的引用的抽象化概念

文件描述符在形式上是一个非负整数，实际上，它是一个索引值，指内核为每一个进程所维护的进程打开文件的记录的记录表，当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。

**缓存IO**

缓存IO，也被称为标准IO，大多数文件系统默认IO操作都是缓存IO，在Linux的缓存IO机制中，操作系统会将IO的数据缓存在文件系统的页缓存（page  cache）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间

缓存IO的缺点：数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的CPU以及内存开销是非常大的。

***

对于一次IO访问（以read为例子），数据会先拷贝到操作系统内核的缓冲区中，然后会从操作系统内核的缓冲区拷贝到应用程序的地址空间，也就是说当一个read操作发生时，它会经历两个阶段：

1. 等待数据准备
2. 经数据从内核拷贝到进程

正是因为这两个阶段，linux系统产生了五种网络模式的方案：

1. 阻塞I/O（blocking IO）

2. 非阻塞I/O（nonblocking IO）

3. I/O多路复用（IO multiplexing）

4. 信号驱动I/O（signal driven IO）

5. 异步I/O（asynchromous IO）

注意：信号驱动I/O（signal driven IO）在实际中不常用。

每个 I/O 模型都有自己的使用模式，它们对于特定的应用程序都有自己的优点。

### 阻塞式 I/O

默认情况下，所有套接字都是阻塞的。

当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：

1. 准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。这个时候kernel就要等待足够的数据到来）。数据被拷贝到操作系统内核的缓冲区中是需要一个过程，这个过程需要等待。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。
2. 当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。

![](https://note-taking-1258869021.cos.ap-beijing.myqcloud.com/python/thread%20process%20IO-blocking.png)

直到阻塞结束recvfrom才能返回。

### 非阻塞式 I/O

linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：

当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。

![](https://note-taking-1258869021.cos.ap-beijing.myqcloud.com/python/thread%20process%20IO-non-blocking.png)

可以看出recvfrom总是立即返回。

### I/O 多路复用

虽然I/O多路复用的函数也是阻塞的，但是其与以上两种还是有不同的，I/O多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I/O系统调用如recvfrom之上。会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。如图：

![](https://note-taking-1258869021.cos.ap-beijing.myqcloud.com/python/thread%20process%20IO-multiplexing.png)

当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。 

这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和  recvfrom)，而blocking IO只调用了一个system call  (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。

所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading +  blocking IO的web  server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）

I/O multiplexing 这里面的 multiplexing 指的其实是在**单个线程**通过记录跟踪每一个Sock(I/O流)的状态(对应空管塔里面的Fight progress strip槽)来同时管理多个I/O流. 发明它的原因，是尽量多的**提高**服务器的吞吐能力。多路网络连接复用一个io线程。

![](https://note-taking-1258869021.cos.ap-beijing.myqcloud.com/python/thread%20process%20IO-multiplexing-1.jpg)

在IO multiplexing  Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket  IO给block。

### 信号驱动式 I/O

用的很少，就不做讲解了。

### 异步 I/O

这类函数的工作机制是告知内核启动某个操作，并让内核在整个操作（包括将数据从内核拷贝到用户空间）完成后通知我们。用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。回调就是用来处理此时返回的结果。

![](https://note-taking-1258869021.cos.ap-beijing.myqcloud.com/python/thread%20process%20IO-asynchronous.png)

调用时就可以立马返回，等函数操作完成会通知我们。

### 总结

 其实前四种I/O模型都是同步I/O操作，他们的区别在于第一阶段，而他们的第二阶段是一样的：在数据从内核复制到应用缓冲区期间（用户空间），进程阻塞于recvfrom调用。相反，异步I/O模型在这两个阶段都要处理。

![](https://note-taking-1258869021.cos.ap-beijing.myqcloud.com/python/thread%20process%20IO5.png)

**blocking IO**的特点就是在IO执行的两个阶段都被block了

**nonblocking IO**的特点是用户进程在内核准备数据的阶段需要不断主动询问kernel数据好了没有

**IO multiplexing**的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。

再看POSIX对这两个术语的定义：

- 同步I/O操作：导致请求进程阻塞，直到I/O操作完成；
- 异步I/O操作：不导致请求进程阻塞。

好，下面我用我的语言来总结一下阻塞，非阻塞，同步，异步

- 阻塞，非阻塞：进程/线程要访问的数据是否就绪，进程/线程是否需要等待；
- 同步，异步：访问数据的方式，同步需要主动读写数据，在读写数据的过程中还是会阻塞；异步只需要I/O操作完成的通知，并不主动读写数据，由操作系统内核完成数据的读写。

**异步VS非阻塞 IO**：二者没有必然关系：前者指任务间的关系，而后者是一项 IO 技术，两者不是同一层次的
概念。但是异步和非阻塞一般被认为是两个可互换使用的词汇 - 因为异步流程之间并不会相互阻塞。

在处理 IO 的时候，阻塞和非阻塞都是同步 IO。只有使用了特殊的 API 才是异步 IO。

![](https://note-taking-1258869021.cos.ap-beijing.myqcloud.com/python/thread%20process%20IO-1.jpg)

I/O复用(select/poll/epoll)都属于同步I/O，因为它们在数据由内核空间复制回进程缓冲区时都是阻塞的(不能干别的事)。只有异步I/O模型(AIO)是符合异步I/O操作的含义的，即在1）数据准备完成、2）由内核空间拷贝回缓冲区后，通知进程，在等待通知的这段时间里可以干别的事。

而异步 IO一般指 IO 读写操作由独立执行流程（a thread of execution）完成，随后将数据交给其它执行流程。

要支持并发，必须拆分为多任务，不同任务相对而言才有阻塞/非阻塞、同步/异步。所以，并发、异步、非阻塞三个词总是如影随形。

***

参考：

https://www.zhihu.com/question/19732473

http://www.cnblogs.com/zhaof/p/5932461.html

https://www.zhihu.com/question/32163005

https://blog.csdn.net/lengxiao1993/article/details/78154467