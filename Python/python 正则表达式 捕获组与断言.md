Python的re模块有一个分组功能。所谓的分组就是去已经匹配到的内容里面再筛选出需要的内容，相当于二次过滤。实现分组靠圆括号`()`，而获取分组的内容靠的是group()、groups()和groupdict()方法。

`()` 标记一个子表达式的开始和结束位置。具有分组的功能，一对括号代表一个分组。

`()` 包括 捕获和断言两大块，这二者又可再次细分，例如普通捕获组和命名捕获组、预测先行断言和回顾后发断言、反向引用等各种能。

***

## 捕获

捕获组就是把正则表达式中子表达式匹配的内容，保存到内存中以数字编号或手动命名的组里，以供后面引用。

这种引用既可以是在正则表达式内部，也可以是在正则表达式外部。

捕获组有两种形式，普通捕获组和命名捕获组。

|类别|表达式|
|:-|:-|
|普通捕获组|`(exp)`|
|命名捕获组|`(?P<name>exp)`|

获取一些 wiki URL 中的信息。

```python
import re

test = "https://en.wikipedia.org/wiki/Python_(programming_language)"

regex = re.compile(r"(\w+):\/\/([^/:]+)\/wiki\/([^# ]*)")
print(regex.findall(test))


输出结果：
[('https', 'en.wikipedia.org', 'Python_(programming_language)')]
```

* 第一个括号子表达式获取协议："https"
* 第二个括号子表达式获取主站 URL："en.wikipedia.org"
* 第三个括号子表达式获取 wiki 词条信息："Python_(programming_language)"

其中，`^` 在 `[]` 中时与其外作用不同。

在 `[]` 中时，表示取反。`[^/:]+` 匹配除 `/:` 之外的任何字符。

获取 HTML 标签中的内容

```python
import re

test = "<p>a<span>b</span><span>c</span></p>"

regex = re.compile(r">([^<>]+?)<")
print(regex.findall(test))


输出结果：
['a', 'b', 'c']
```

当含有嵌入的 `()` 时：

```python
test = "abc def ghi jkl mno"

regex1 = re.compile(r"\w+\s+\w+")
print("regex1:", regex1.findall(test))

regex2 = re.compile(r"(\w+)\s+\w+")
print("regex2:", regex2.findall(test))

regex3 = re.compile(r"(\w+)\s+(\w+)")
print("regex3:", regex3.findall(test))

regex4 = re.compile(r"((\w+)\s+\w+)")
print("regex4:", regex4.findall(test))


输出结果：
regex1: ['abc def', 'ghi jkl']
regex2: ['abc', 'ghi']
regex3: [('abc', 'def'), ('ghi', 'jkl')]
regex4: [('abc def', 'abc'), ('ghi jkl', 'ghi')]
```

* regex1 中没有括号，因此获取所有内容；
* regex2 中有1个括号，因此仅获取括号中内容；
* regex3 中有2个分离括号，2者返回作为1个 tuple 获取；
* regex4 中有2个嵌套括号，在获取全部的基础上，再次获取嵌套在里边的 () 中的内容。

```python
import re

test = "a0000a11a1b2b22b2c3c3c333"

regex1 = re.compile(r"([a-z]\d+)")
print("regex1:", regex1.findall(test))

regex2 = re.compile(r"([a-z]\d)+")
print("regex2:", regex2.findall(test))

regex3 = re.compile(r"(([a-z]\d)+)")
print("regex3:", regex3.findall(test))

regex4 = re.compile(r"([a-z]\d)+?")
print("regex4:", regex4.findall(test))


输出结果：
regex1: ['a0000', 'a11', 'a1', 'b2', 'b22', 'b2', 'c3', 'c3', 'c333']
regex2: ['a0', 'a1', 'b2', 'c3']
regex3: [('a0', 'a0'), ('a1', 'a1'), ('a1b2b2', 'b2'), ('b2c3c3c3', 'c3')]
regex4: ['a0', 'a1', 'a1', 'b2', 'b2', 'b2', 'c3', 'c3', 'c3']

```

对比观察 regex2 和 regex3 的区别，我们为了获取：a0、a1、a1b2b2、b2c3c3c3 这组数据。

下图表头0、1、2均为分组，0号组的是匹配的整个表达式。由此可见，regex2 匹配到了我们想要的数据，但是仅仅返回了圆括号中的内容。当在将其再次放入一个圆括号中时，即 regex3 的正则表达式，即可返回想要的数据。

![regex2](https://wx4.sinaimg.cn/mw690/af9e9c30ly1fsdxpyhqsxj204l03d0sh.jpg)

![regex3](https://wx1.sinaimg.cn/mw690/af9e9c30ly1fsdxpwakvaj207n03dgld.jpg)

***

### 非捕获组

一些表达式中，不得不使用 `()`，但又不需要保存 `()` 中子表达式匹配的内容，这时可以用非捕获组来抵消使用 `()` 带来的副作用。

当需要将一部分规则作为一个整体对它进行匹配，比如还有字符串时，可以采用无捕获分组，即：`(?:exp)`。不会影响其他组的序号。无捕获分组剥夺一个分组对组号分配的参与权。

```python
test = "i have a dog, i have 2 cats."
```

正则表达式：`(?:dog|cat)`

![非捕获](https://wx4.sinaimg.cn/thumb150/af9e9c30ly1fsgj6ynldaj20200230pq.jpg)

正则表达式：`(dog|cat)`

![捕获](https://wx3.sinaimg.cn/mw690/af9e9c30ly1fsgj701i7fj201v025a9t.jpg)

**tip**：不得不使用 `()` 的情况：

* 使用 `|` 时，用 `()` 限制范围。

举例：匹配0到100的数字

正则表达式：`(?:[1-9]?[0-9]|100)`

* 使用量词限定一个子表达式整体的匹配次数。

举例：匹配 `HH:mm:ss` 格式时间

正则表达式：`([01][0-9]|2[0-3])(:[0-5][0-9]){2}`

这里的 `{2}` 是对前面的 `:[0-5][0-9]` 整体作修饰，因此要用 `()` 来限定修饰的范围。

* 某些时候为了使捕获组的编号可控，可能会用到非捕获组。

当 `()` 仅仅是用作分组，而不需要捕获内容时，而且表达式中使用 `()` 很多，可以使用非捕获组提升效率。

***

### 捕获组编号规则

捕获组在匹配成功时，会将子表达式匹配到的内容，保存到内存中一个以数字编号或指定命名的组里，可以简单的认为是对一个局部变量进行了赋值。所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。

#### 只有普通捕获组

只有普通捕获组的情况下，捕获组的编号是按照 `(` 出现顺序，从左到右，从1开始进行编号的 。

正则表达式：`(\d{4})-(\d{2}-(\d\d))`

![普通捕获](https://note-taking-1258869021.cos.ap-beijing.myqcloud.com/python/re-2.png)

![普通捕获结果](https://wx2.sinaimg.cn/mw690/af9e9c30ly1fsgcdcp9goj207h0120no.jpg)

#### 只有命名捕获组

命名捕获组通过显式命名，可以通过组名访问指定组，而不需要去查编号，同时避免了在正则表达式扩展过程中，因捕获组的增加或减少，引起的引用结果的不可控。

需要注意的是，命名捕获组也参与了编号，在只有命名捕获组的情况下，捕获组的编号也是按照 `(` 出现顺序，从左到右，从1开始进行编号。

正则表达式：`(?<year>\d{4})-(?<date>\d{2}-(?<day>\d\d))`

![命名捕获](https://note-taking-1258869021.cos.ap-beijing.myqcloud.com/python/re-3.png)

![命名捕获结果](https://wx1.sinaimg.cn/mw690/af9e9c30ly1fsgcddtqskj207g0130sh.jpg)

#### 二者混合捕获组

在混合方式的捕获组中，首先按照普通捕获组中 `(` 出现顺序，从左到右，从1开始进行编号。当普通捕获组编号完成后，再按命名捕获组中 `(` 出现顺序，从左到右，接着普通捕获组的编号值继续进行编号。

实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号。

![混合捕获](https://note-taking-1258869021.cos.ap-beijing.myqcloud.com/python/re-4.png)

![混合捕获结果](https://wx2.sinaimg.cn/mw690/af9e9c30ly1fsgcdiay6ij207h0170ph.jpg)

***

### 捕获组的引用

正则表达式中，对前面捕获组捕获的内容进行引用，称为反向引用。

普通捕获组反向引用：`\number`。

命名捕获组反向引用：`(?P=name)`。

#### 普通捕获组的反向引用

```python
test = "aa,cdd,eff,ghg"
regEx = re.compile(r'([abcd])\1')
print(regEx.findall(test))


输出结果：
['a', 'd']
```

捕获组中的子表达式 `[ab]` 虽然可以匹配 `a` 或者 `b` ，但是捕获组一旦匹配成功，反向引用的内容也就确定了。如果捕获组匹配到 `a`，那么反向引用也就只能匹配 `a`，同理，如果捕获组匹配到的是 `b`，那么反向引用也就只能匹配 `b`。

'([abcd])\1' 改为 '([abcd])\1{2}' 即可匹配三个连续的字符。

#### 命名捕获组的反向引用

```python
test = "Is is the cost of of gasoline going up up"
regEx = re.compile(r'\b(?P<words>[a-z]+) (?P=words)\b', re.I)
print(regEx.findall(test))


输出结果：
['Is', 'of', 'up']
```

#### 应用场景

* 12位数字，其中不能出现6位连续相同数字

```python
test = "123456789012,123333334567"
regEx = re.compile(r'((?:([0-9])(?!\2{5})){12})', re.I)
print(regEx.findall(test))


输出结果：
[('123456789012', '2')]
```

* 替换文本

```python
import re

s = "Tom is talking to Jerry."
name1 = "Tom"
name2 = "Jerry"

pattern = r'(.*)({0})(.*)({1})(.*)'.format(name1, name2)
print(re.sub(pattern, r'\1\4\3\2\5', s))
```

***

## 断言/环视

由不同的分类方法，有断言和环视两种名称。二者只是名称稍有不同，均是针对位置。

断言只进行子表达式的匹配，匹配内容不计入最终的匹配结果，是零宽度的。匹配结果不包含表达式本身。匹配的最终结果就是一个位置。断言交出控制权时，会丢弃所有回溯状态，只返回一个位置。

断言作用相当于对匹配位置加了一个附加条件，只有满足这个条件，子表达式才能匹配成功。

python 的 re 模块并不支持长度不确定的后发断言，只支持固定长度的后发断言子表式。

需要注意的是，虽然4种断言均只返回位置，不返回字符。但是类似 `(?<=(exp1)exp2)exp3` 或 `exp3(?=(exp1)exp2)` 中的 `(exp2)` 的字符会被返回。例如 `(?=(\d)\d)\1` 和 `\d(?=(\d))\1`。

分类1：

|表达式|说明|
|:-|:-|
|`(?=exp)`|零宽度正预测先行断言，所在位置右侧能够匹配 exp|
|`(?<=exp)`|零宽度正回顾后发断言，所在位置左侧能够匹配 exp|
|`(?!exp)`|零宽度负预测先行断言，所在位置右侧不能匹配 exp|
|`(?<!exp)`|零宽度负回顾后发断言，所在位置左侧不能匹配 exp|

分类2：

|表达式|说明|
|:-|:-|
|`(?=exp)`|顺序肯定环视，表示所在位置右侧能够匹配 exp|
|`(?!exp)`|顺序否定环视，表示所在位置右侧不能匹配 exp|
|`(?<=exp)`|逆序肯定环视，表示所在位置左侧能够匹配 exp|
|`(?<!exp)`|逆序否定环视，表示所在位置左侧不能匹配 exp|

***

### 零度断言

* `(?=exp)`:零宽度正预测先行断言，也称作顺序肯定环视。匹配自身所在位置的右侧的表达式 exp。断言 exp 一定在匹配位置的右侧，即断言后面一定跟着 exp。

对于 `(?=exp)` 来说，当子表达式 exp 匹配成功时，`(?=exp)` 匹配成功，返回 `(?=exp)` 当前位置。

* `(?<=exp)`:零宽度正回顾后发断言，也称作逆序肯定环视。匹配自身所在位置的左侧的表达式 exp。断言 exp 一定在匹配位置的左侧，即断言前面一定有 exp 前缀。

对于 `(?<=exp)` 来说，当子表达式 exp 匹配成功时，exp 匹配成功，`(?<=exp)` 匹配成功，返回 `(?<=exp)` 当前位置。

提取 HTML 中的信息：

```python
test = "<p> hello world </p>"
regEx = re.compile(r'(?<=<\w{1}>).*(?=</\w{1}>))')
print(regEx.findall(test))


输出结果：
[' hello world ']
```

如果将上述正则表达式中 `\w{1}` 改为 `\w+`，python 则会报错误： `sre_constants.error: look-behind requires fixed-width pattern`。所以，在零宽度正回顾后发断言中不能有不确定长度的表达式。

***

### 负零度断言

相对零宽度断言，负零宽度断言表达式是否定的。

* `(?!exp)`:零宽度负预测先行断言，也称作顺序否定环视。断言 exp 不在匹配位置的右侧，即断言后面不能跟着 exp。

对于 `(?!exp)` 来说，当子表达式 exp 匹配成功时，`(?!exp)` 匹配失败；当子表达式 exp 匹配失败时，`(?!exp)` 匹配成功，并返回 `(?!exp)` 当前位置；

* `(?<!exp)`:零宽度负回顾后发断言，也称作逆序否定环视。断言 exp 不在匹配位置的左侧，即断言前面没有 exp 前缀。

对于 `(?<!exp)` 来说，当子表达式 exp 匹配成功时，`(?<!exp)` 匹配失败；当子表达式 exp 匹配失败时，`(?<!exp)` 匹配成功，并返回 `(?<!exp)` 当前位置；

```python
test = "do doing ding, going gone"
regEx = re.compile(r'(?![do])\w+')
print(regEx.findall(test))
regEx = re.compile(r'\w+(?<![ing])')
print(regEx.findall(test))


输出结果：
['ing', 'ing', 'going', 'gone']
['do', 'do', 'd', 'go', 'gone']
```

***

### 匹配原理1---`(?!exp)`

下面的正则表达式匹配除 `<p…>` 或 `<\/p>` 之外的其余标签。

```python
test = "a<p>one</p>b<div>two</div>c"
regEx = re.compile(r'<(?!/?p\b)[^>]+>')
print(regEx.findall(test))


输出结果：
['<div>', '</div>']
```

匹配过程：

![匹配过程](https://note-taking-1258869021.cos.ap-beijing.myqcloud.com/python/re-5.png)

* 首先，由 `<` 获得控制权，由位置0开始匹配。由于`<` 匹配 `a` 失败，正则引擎向前传动，在位置1处开始第二次匹配。在成功匹配前，一直重复此过程。

* 直至位置1，`<` 匹配 `<` 成功，控制权交给 `(?!/?p\b)`。

* `(?!/?p\b)` 子表达式取得控制权后，进行内部子表达式的匹配。首先由 `/?` 取得控制权，尝试匹配 `p` 失败，进行回溯，不匹配，控制权交给 `p`。`p` 尝试匹配 `p` ，匹配成功，控制权交给 `\b`。`\b` 尝试匹配位置3，匹配成功。

* 此时子表达式匹配完成，`/?p\b` 匹配成功，则表达式 `(?!/?p\b)` 匹配失败。在位置1处整个表达式匹配失败，这一轮迭代匹配失败，正则引擎向前传动，由位置2处开始尝试下一轮迭代匹配。

* 重复以上过程，直至位置12，`<` 匹配成功，将控制权再次传递给 `(?!/?p\b)`。`/?p\b` 匹配 `div` 失败，则表达式 `(?!/?p\b)` 匹配成功，匹配结果是位置13，然后控制权交给 `[^>]+`。

* `[^>]+` 从位置13进行尝试匹配，成功匹配到 `div` ，控制权交给 `>`。

* `>` 获得控制权，并成功匹配 `>`。正则表达式匹配完成。

* 匹配结果为 `<div>` ，开始位置为12，结束位置为17。其中 `<` 匹配 `<` ，`(?!/?p\b)` 匹配位置13，`[^>]+` 匹配字符串 `div`，`>` 匹配 `>` 。

`(?=exp)` 的匹配过程与 `(?=exp)` 相同，这同时是顺序环视匹配过程。顺序环视相当于在当前位置右侧附加一个条件，所以它的匹配尝试是从当前位置开始的，然后向右尝试匹配，直到某一位置使得匹配成功或失败为止。

***

### 匹配原理2---`(?<=exp)`

下面的正则表达式匹配 `<div>` 与 `</div>` 标签之间的内容，且不包括 `<div>` 和 `</div>` 标签本身。

```python
test = "<div>a test</div>"
regEx = re.compile(r'(?<=<div>)[^<]+(?=</div>)')
print(regEx.findall(test))


输出结果：
['a test']
```

匹配过程：

![匹配过程](https://note-taking-1258869021.cos.ap-beijing.myqcloud.com/python/re-6.png)

* 首先，`(?<=<div>)` 取得控制权，从位置0开始匹配。由于位置0是起始位置，左侧没有任何内容，所以 `<div>` 必然匹配失败，以至于表达式 `(?<=<div>)` 匹配失败，从而导致整个表达式在位置0处匹配失败。第一轮迭代匹配失败，正则引擎向前传动，由位置1处开始尝试第二次迭代匹配。

* 重复以上过程，直到传动到位置5。`(?<=<div>)` 取得控制权。由于 `<div>` 的长度固定为5，所以会从当前位置向左查找5个字符，从位置0开始匹配。`<div>` 匹配 `<div>` 成功，所以 `(?<=<div>)` 匹配成功，匹配结果是位置5，控制权交给 `[^<]+`。

* `[^<]+` 从位置5开始尝试匹配，匹配 `a test` 成功，控制权交给 `(?=</div>)`。

* `</div>` 匹配 `</div>` 成功，所以 `(?=</div>)` 匹配成功，匹配结果是位置11。正则表达式匹配完成。

* 匹配结果为 `a test` ，开始位置为5，结束位置为11。其中 `(?<=<div>)` 匹配位置5，`[^<]+` 匹配 `a test`，`(?=</div>)`匹配位置11。

`(?<!exp)` 的匹配过程与 `(?<=exp)` 相同，这同时是逆序环视匹配过程。逆序环视的特殊处在于，它相当于在当前位置左侧附加一个条件，所以它不是在当前位置开始尝试匹配的，而是从当前位置左侧某一位置开始，匹配到当前位置为止，返回匹配成功或失败。

顺序环视尝试匹配的起点是确定的，就是当前位置，而匹配的终点是不确定的。逆序环视匹配的起点是不确定的，是当前位置左侧某一位置，而匹配的终点是确定的，就是当前位置。

***

### 类似`(?=(exp1)exp2)exp3`

需要注意的是，虽然4种断言均只返回位置，不返回字符。但是类似 `(?=(exp1)exp2)exp3` 中的 `(exp1)` 的字符会被返回。尤其在其他编程语言中，当后发断言不限定长度时，`exp2` 是否为贪婪匹配会造成影响。例如 `(?<=(\d)\d*)\1` 与 `(?<=(\d)\d*?)\1`。

|| `(?<=(\d)\d*)\1` | `(?<=(\d)\d*?)\1` |
|:-|:-|:-|
| 878 |8|None|
| 9878 |None|None|

* `(?<=(\d)\d*)\1` 中，匹配 878 的1分组存储的8，匹配位置是2。匹配 9878 的1分组存储的9，永远不会匹配成功。

* `(?<=(\d)\d*?)\1`中，`\d*?` 因为在断言中，优先不匹配，且交出控制权时会同时丢弃所有回溯状态，所以可以认为基本不参与匹配。于是，整个表达式可以简化为 `(?<=(\d))\1`。所以无论878还是9878，都不会成功。

***

参考：

[雁过无痕](https://blog.csdn.net/lxcnn)