Python的GC(Garbage collection)模块主要运用了“引用计数”（reference counting）来跟踪和回收垃圾。在引用计数的基础上，还可以通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用的问题。通过“分代回收”（generation collection）以空间换取时间来进一步提高垃圾回收的效率。以引用计数机制为主，标记-清除和分代收集两种机制为辅的策略。

GC系统所承担的工作远比"垃圾回收"多得多。实际上，它们负责三个重要任务。它们

- 为新生成的对象分配内存
- 识别那些垃圾对象
- 并且，从垃圾对象那回收内存。

## 引用计数

在Python中，大多数对象的生命周期都是通过对象的引用计数来管理的。

引用计数的原理：每一个对象都有一个计数器，用来标记这个对象被引用的次数(比如被1个变量引用则为1,被2个变量引用则为2)。当一个对象的引用被创建或者复制时，对象的引用计数加1；当一个对象的引用被销毁时，对象的引用计数减1；当对象的引用计数减少为0时，就意味着对象已经没有被任何人使用了，可以将其所占用的内存释放了。

python里每一个东西都是对象，它们的核心就是一个结构体：`PyObject`

```
 typedef struct_object {
 int ob_refcnt;
 struct_typeobject *ob_type;
} PyObject;
```

PyObject是每个对象必有的内容，其中`ob_refcnt`就是做为引用计数。当一个对象有新的引用时，它的`ob_refcnt`就会增加，当引用它的对象被删除，它的`ob_refcnt`就会减少

```
#define Py_INCREF(op)   ((op)->ob_refcnt++) //增加计数
#define Py_DECREF(op) \ //减少计数
    if (--(op)->ob_refcnt != 0) \
        ; \
    else \
        __Py_Dealloc((PyObject *)(op))
```

引用计数机制执行效率问题：引用计数机制所带来的维护引用计数的额外操作与Python运行中所进行的内存分配和释放，引用赋值的次数是成正比的。而这点相比其他主流的垃圾回收机制，比如“标记-清除”，“停止-复制”，是一个弱点，因为这些技术所带来的额外操作基本上只是与待回收的内存数量有关。

如果说执行效率还仅仅是引用计数机制的一个软肋的话，那么很不幸，引用计数机制还存在着一个致命的弱点，正是由于这个弱点，使得侠义的垃圾收集从来没有将引用计数包含在内，能引发出这个致命的弱点就是循环引用（也称交叉引用）。

循环引用可以使一组对象的引用计数不为0，然而这些对象实际上并没有被任何外部对象所引用，它们之间只是相互引用。这意味着不会再有人使用这组对象，应该回收这组对象所占用的内存空间，然后由于相互引用的存在，每一个对象的引用计数都不为0，因此这些对象所占用的内存永远不会被释放。

```bash
list1 = []
list2 = []
list1.append(list2)
list2.append(list1)
```

list1与list2相互引用，如果不存在其他对象对它们的引用，list1与list2的引用计数也仍然为1，所占用的内存永远无法被回收，这将是致命的。

## 标记-清除

引用计数不能处理环形数据结构--也就是含有循环引用的数据结构。Python中的循环引用总是发生在container对象之间，也就是能够在内部持有其它对象的对象，比如list、dict、class等等。标记-清除只会关注新创建的对象，以及因为引用计数为零而被释放掉的对象的追踪

Python会循环遍关注列表上的每个对象，检查列表中每个互相引用的对象，根据规则减掉其引用计数的副本，然后根据reachable和unreachable规则进行垃圾回收。实际上这个规则是有点复杂的：

本质上：把这些container对象组成一个大集合，检测这个集合里的container对象有没有被其他container对象引用，如果有，那么直接计数-1.那么问题来了，加入A引用了B，B却没有引用A。按照我们制定的规则，B的ob_refcnt会变成0，然后被删除，但是实际上A和B并没有循环引用。所以如果直接按照这种逻辑处理，就会出现错误：A对B的引用变成了悬空引用。

所以Python这里加入了一个巧妙的设计：

step1:将对象的ob_refcnt复制，这样就有了ob_refcnt的副本。这样可以上述例子中的B的ob_refcnt变成0，从而避免悬空引用的出现。

step2: 根据副本ob_refcnt的值是否为0，将对象集合分为两个子集合：reachable和unreachable。reachable集合中的对象的副本ob_refcnt不为0，unreachable集合中的副本ob_refcnt为0，那么unreachable就是可以被回收的对象。回到例子中，A属于reachable，B属于unreachable。

step3: 检查reachable集合中的对象，如果其中有对象引用了unreachable集合中的对象，那么把unreachable集合中的这个对象放到reachable集合中来。回到例子中，因为A引用了B，所以B被从unreachable中调整到了reachable中。

step4: 检查step3中是否有新的对象从unreachable中调整到了reachable中；如果有，重复step3(考虑一下A引用B，B引用C的例子，你就知道step4的意义了)

step5: 清除unreachable集合中的对象。

缺点：标记和清除的过程效率不高。

显然，标记-清除是非常消耗系统资源的，所以下面又引入了分代收集的方法。

## 分代回收

这种算法的根源来自于弱代假说(weak generational hypothesis)。这个假说由两个观点构成：首先是年亲的对象通常死得也快，而老对象则很有可能存活更长的时间。

换种说法：老对象因为已经存活很长时间了，是垃圾对象的可能性更小，所以检测频率可以降低。新对象是垃圾对象的概率大，所以检测频率要高一点才行。

分代回收的原理是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。

Python默认定义了三代对象集合，索引数越大，对象存活时间越长。

Python的收集机制后，触发上边所说到的零代算法，释放“浮动的垃圾”，并且将剩下的对象移动到一代列表。

随着时间的推移，程序所使用的对象逐渐从零代列表移动到一代列表。而Python对于一代列表中对象的处理遵循同样的方法，一旦被分配计数值与被释放计数值累计到达一定阈值，Python会将剩下的活跃对象移动到二代列表。

通过这种方法，你的代码所长期使用的对象，那些你的代码持续访问的活跃对象，会从零代链表转移到一代再转移到二代。通过不同的阈值设置，Python可以在不同的时间间隔处理这些对象。Python处理零代最为频繁，其次是一代然后才是二代。

## gc 模块

gc模块提供一个接口给开发者设置垃圾回收的选项。

***

参考：

http://python.jobbole.com/82061/

http://www.cnblogs.com/pinganzi/p/6646742.html

https://www.cnblogs.com/ArsenalfanInECNU/p/9077967.html