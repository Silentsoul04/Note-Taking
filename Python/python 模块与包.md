在编程语言中，代码块、函数、类、模块，一直到包，逐级封装，层层调用。在Python中，一个.py文件就是一个模块，模块是比类更高一级的封装。在其他语言，被导入的模块也通常称为库。

模块可以分为自定义模块、内置模块和第三方模块。

使用模块有什么好处？

- 首先，提高了代码的可维护性。
- 其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他的模块引用。不要重复造轮子，我们简简单单地使用已经有的模块就好了。
- 使用模块还可以避免类名、函数名和变量名发生冲突。相同名字的类、函数和变量完全可以分别存在不同的模块中。但是也要注意尽量不要与内置函数名（类名）冲突。

为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包（Package），包是模块的集合，比模块又高一级的封装。没有比包更高级别的封装，但是包可以嵌套包。

包名通常为全部小写，避免使用下划线。

## 模块

### 调用

由于一个模块可能会被一个包封装起来，而一个包又可能会被另外一个更大的包封装起来，所以我们在导入的时候，需要提供导入对象的绝对路径，也就是

`最顶层的包名.次一级包名.（所有级别的包名）.模块名.类名.函数名`

类似文件系统的路径名，只是用圆点分隔的。

对于`xx.xx`，你想导入到哪个级别，取决于你的需要，可以灵活调整，没有固定的规则。

```text
import xx.xx
这会将对象（这里的对象指的是包、模块、类或者函数，下同）中的所有内容导入。

from xx.xx import xx.xx
从某个对象内导入某个指定的部分到当前命名空间中，不会将整个对象导入。这种方式可以节省写长串导入路径的代码，但要小心名字冲突。

from xx.xx import xx as rename
为了避免命名冲突，在导入的时候，可以给导入的对象重命名。

from xx.xx import *
将对象内的所有内容全部导入。非常容易发生命名冲突，请慎用！
```

### 模块搜索路径

不管在程序中执行了多少次import，一个模块只会被导入一次。这样可以防止一遍又一遍地导入模块，节省内存和计算资源。那么，当使用import语句的时候，Python解释器是怎样找到对应的文件的呢？

Python根据sys.path的设置，按顺序搜索模块。

默认情况下，模块的搜索顺序是这样的：

1. 当前执行脚本所在目录
2. Python的安装目录
3. Python安装目录里的site-packages目录

其实就是“自定义”——>“内置”——>“第三方”模块的查找顺序。任何一步查找到了，就会忽略后面的路径，所以模块的放置位置是有区别的。

***

## 包

包是一种管理模块的手段，采用“包名.子包名.....模块名”的调用形式，非常类似文件系统中的文件目录。但是包不等于文件目录！文件夹被python解释器视作package需要满足两个条件：

* 文件夹中必须有`__init__.py`文件，该文件可以为空，但必须存在该文件
* 不能作为顶层模块来执行该文件夹中的py文件（即不能作为主函数的入口）。

在"from YY import XX"这样的代码中，无论是XX还是YY，只要被python解释器视作package，就会首先调用该package的`__init__.py`文件。

`__init__.py`可以是空文件，也可以有Python代码，`__init__.py`本身就是一个模块，但是要注意，它的模块名是它所在的包名而不是`__init__`。

在`__init__.py`可以设置精确的模块索引。如果包定义文件`__init__.py`中存在一个叫做`__all__`的列表变量，那么在使用`from package import *`的时候就把这个列表中的所有名字作为要导入的模块名。

例如在`example/p1/__init__.py`中包含如下代码:

```
__all__ = ["x"]
```

这表示当你使用`from example.p1 import *`这种用法时，你只会导入包里面的x子模块。

***

摘抄：

http://www.liujiangblog.com/course/python/51