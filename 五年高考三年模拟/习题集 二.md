1. **人名币大写转换。**

```python
No2CN = {0: u'零', 1: u'壹', 2: u'贰', 3: u'叁', 4: u'肆', 5: u'伍',
            6: u'陆', 7: u'柒', 8: u'捌', 9: u'玖'}
units = [u'亿', u'仟', u'佰', u'拾', u'万', u'仟', u'佰', u'拾', u'圆']
replace_zero = [
    (u'零仟', u'零佰', u'零拾', u'零零零', u'零零', u'零万', u'零圆'),
    (u'零', u'零', u'零', u'零', u'零', u'万', u'圆')
    ]

b = abs(a)
new = []
for i in str(b):
    if int(i) in No2CN.keys():
        new.append(No2CN[int(i)])
units_new = units[-len(new):]
result = ''
for i, j in zip(new, units_new):
    result += i+j
for i, j in zip(replace_zero[0], replace_zero[1]):
    result = result.replace(i, j)
if a < 0:
    print(u'负'+result)
else:
    print(result)
```

* 整理思路

```python
M = [u'零', u'壹', u'贰', u'叁', u'肆', u'伍', u'陆', u'柒', u'捌', u'玖']
N = ['', u'圆', u'拾', u'佰', u'仟', u'万', u'拾', u'佰', u'仟', u'亿']
O = {
    u'零仟': u'零', u'零佰': u'零', u'零拾': u'零', u'零零零': u'零', u'零零': u'零',
    u'零万': u'万', u'零圆': u'圆', u'亿万': u'亿'
    }

s = str(abs(a))
r = ('' if a >= 0 else '负')
for i in range(0, len(s)):
    r = r + M[int(s[i])] + N[len(s)-i]
for i in range(len(s)):
    for j in O:
        r = r.replace(j, O[j])
print(r if a != 0 else u'零圆')
```

***

2. **简单加密**给你个小写英文字符串a和一个非负数b(0<=b<26), 将a中的每个小写字符替换成字母表中比它大b的字母。这里将字母表的z和a相连，如果超过了z就回到了a。例如a="cagy", b=3，则输出 ：fdjb

```python
c = ''
for i in a:
    if ord(i)+b <= ord('z'):
        c += chr(ord(i)+b)
    else:
        c += chr(ord(i)+b-26)
print(c)
```

* 整理思路

```python
c = ''
for i in a:
    c += chr((ord(i)+b-ord('a'))%26 + ord('a'))
print(c)
```

***
**3.回文：**给你一个字符串a和一个正整数n,判断a中是否存在长度为n的回文子串。如果存在，则输出YES，否则输出NO。

```python
def foo(text, n):
    for i in range(len(text)-n+1):
        if text[i:i+n] == text[i:i+n][::-1]:
            return text[i:i+n]
        if i == len(text)-n:
            return 'NONE'
```

***

4. **给你两个时间st和et(00:00:00<=st <= et<=23:59:59), 请你给出这两个时间间隔的秒数。如：st="00:00:00", et="00:00:10", 则输出10。**

```python
from datetime import datetime
print((datetime.strptime(et, '%H:%M:%S')-datetime.strptime(st, '%H:%M:%S')).seconds)
```

***

5. **闰年判定，365 Or 366？：**现在给你一个年份year(year为四位数字的字符串，如"2008","0012"),你输出这一年的天数。如year="2013", 则输出365。

```python
year = int(year)
if year%400 == 0:
    print(366)
elif (year%4 == 0) and (year%100 != 0):
    print(366)
else:
    print(365)
```

***

6. **扑克牌，并随机抽牌**

```python
import collections, random

Card = collections.namedtuple('Card', ['rank', 'suit'])

class FrenchDeck:
    ranks = [str(n) for n in range(2, 11)] + list('JQKA')
    suits = 'spades diamonds clubs hearts'.split()

    def __init__(self):
        # 52张
        self._cards = [Card(rank, suit) for suit in self.suits
                                        for rank in self.ranks]
    
    def __len__(self):
        return len(self._cards)

    def __getitem__(self, position):
        return self._cards[position]

deck = FrenchDeck()
print(random.choice(deck))
```

***

7. **统计字符串里的字符数量：**输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数

```python
def foo():
    alpha = 0
    digit = 0
    space = 0
    others = 0
    string = input('input a string:\n')
    for item in string:
        if item.isalpha():
            alpha += 1
        elif item.isdigit():
            digit += 1
        elif item.isspace():
            space += 1
        else:
            others += 1
    return alpha, digit, space, others
```

***

8. **打印菱形：**输出如下：

```text
    *    
   ***   
  *****  
 ******* 
*********
 ******* 
  *****  
   ***   
    * 
```

```python
def foo(n):
    for i in range(1, n, 2):
        print('{: ^15}'.format('*'*i))
    if n%2 == 0:	#奇偶转换
        n -= 3
    for j in range(n, 0, -2):
        print('{: ^15}'.format('*'*j))

```

***

9. **翻转字符串：**'abc123'

```python
print(text[::-1])
```

***

10. **合并两个有序序列**：不使用‘sort()’函数

```python
def foo(lst1, lst2):
    lst_r = []
    lst1_ind, lst2_ind= 0, 0
    lst1_len = len(lst1)
    lst2_len = len(lst2)
    while (lst1_ind<lst1_len) and (lst2_ind<lst2_len):	# 当任意一个列表遍历完，则跳出循环
        if lst1[lst1_ind] < lst2[lst2_ind]:
            lst_r.append(lst1[lst1_ind])
            lst1_ind += 1
        else:
            lst_r.append(lst2[lst2_ind])
            lst2_ind += 1
    lst_r.extend(lst1[lst1_ind:])
    lst_r.extend(lst2[lst2_ind:])
    return lst_r
```

***

11. **时间转换：**请将下列形式的字符串转换成秒数，2小时3分55秒：7435，35分21秒：2121，55秒：55

```python
import re

def foo(text):
    seconds = 0
    text = text.replace('小时', '时')
    text_lst = re.split('[时分秒]', text)[:-1]	# 去除末尾''元素
    units = 1
    for item in text_lst[::-1]:
        seconds += int(item)*units
        units *= 60
    return seconds
```

***

12. **最长的数字串：**输出字符串str中的连续最长的数字串，例如：abcd12345ed125ss123456789

```python
def foo(text):
    import re
    regEx = re.compile(r'[0-9]+')
    digits = regEx.findall(text)
    digits = [int(i) for i in digits]
    digits = max(digits)
    return digits
```

***

13. **矩阵元素相乘：**A[n,m]是一个n行m列的矩阵，a[i，j]表示A的第i行j列的元素，定义x[i，j]为A矩阵除了a[i，j]之外，所有元素(共n*m-1个)的乘积，即

    x[i，j]=a[i，1]*a[i，2]*…*a[i，j-1]*…*a[i，m]*a[1，j]*a[2，j]…*a[i-1，j]*a[i+1，j]…*a[n，j]

    现输入非负整形的矩阵A[n，m]，求MAX(x[i，j])，即所有的x[i，j]中的最大值。

```python
from functools import reduce


def foo(lst, m, n): # m行n列
    lst_new = [i for j in lst for i in j]   # 列表展平
    lst_new.remove(lst[m][n])
    result = reduce(lambda x,y: x*y, lst_new)
    return result

def func(lst):
    m = len(lst)
    n = len(lst[0])
    #x = [[foo(lst, i, j) for j in range(n)] for i in range(m)]	# x矩阵推导式
    max_r = 0
    for i in range(m):
        for j in range(n):
            r = foo(lst, i, j)
            if max_r < r:
                max_r = r
    return max_r
```

***

14. **位运算 | ：**给定 x, k ，求满足 x + y = x | y 的第 k 个最小的正整数 y 。 | 是二进制的或(or)运算，例如 3 | 5 = 7。 比如：当 x=5，k=1时返回 2，5+2=5|2；k=2时，5+8=5|8

```python
def func(base, index):
    num = 0
    count = 0
    while True:
        num += 1
        if base+num == base|num:
            count += 1
            if count == index:
                return num
```

***

15. **位运算：**两个int32整数m和n的二进制表达，有多少个位(bit)不同？输入：1999   2299，输出：7

```python
def func(a, b):
    c = a ^ b
    count = 0
    while c>0:
        if c&1:
            count += 1
        c = c >> 1
    return count
```

***

16. **最大收益：**有两次买入卖出股票的机会，并且买入前一定要先保证手上没有股票。若两次交易机会都放弃，收益为0。 计算能获得的最大收益。输入：[3,8,5,1,7,8]；输出：12

```python
def profit_get(lst, start, end):
    profit = 0
    for i in range(start, end):
        for j in range(i+1, end+1):
            tmp = lst[j] - lst[i]
            if tmp>profit:
                profit = tmp
    return profit

def profit_max(lst):
    profit = 0
    for i in range(1, len(lst)):
        profit1 = profit_get(lst, 0, i)	# 数组分成两个数组，各自计算买卖的最大收益
        profit2 = profit_get(lst, i+1, len(lst)-1)
        tmp = profit1 + profit2
        if tmp>profit:
            profit = tmp
    return profit
```

***

